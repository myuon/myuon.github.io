---
title: ぴよ
date: 2017-12-01
---

* Isabelleの基本

さて、今回から実際にIsabelleによる証明を書いていこうと思います。
一応極基本的なことを最初に少し説明をしてから、あとは実践形式で実際に証明を書きながら細かい機能などの説明をしていく予定です。
説明に割くページ数とコンテンツの内容と時間的な問題で、定理証明とは何かなどは詳しく話しません。

** jEditについて

現在Isabelleが公式にサポートしているのはjEditのみです[fn:1]。
jEditを起動し、エディター画面とアウトプットパネルが表示されていれば問題ありません。アウトプットパネルはなければ =Plugins>Isabelle= から表示させます。

よく使うパネルを一通り説明しておきます。

- Documentation: Isabelleは豊富な公式ドキュメントが用意されています。全く何も知らない状態なら、最初はTutorialsの[[https://isabelle.in.tum.de/dist/Isabelle2017/doc/prog-prove.pdf][prog-prove.pdf]]だけは *必ず読みましょう* 。またReference Manualsの[[https://isabelle.in.tum.de/dist/Isabelle2017/doc/isar-ref.pdf][isar-ref]]は参照する機会が多いと思います。
- Sidekick: 現在開いているファイルのアウトライン的なものが表示されます。
- State: なんやねんこれ
- Theories: 複数のファイルを開いている場合に、各ファイルのどの辺りまでcheckerが走っているかが一覧で表示されたものです。
- Output: ここに情報が表示されます。証明は基本的にこのパネルを見ながら書きます。
- Query: 既知の定理の検索などを行います。
- Sledgehammer: 現在focusしている証明に対してsledgehammer(後述)を実行することができます。
- Symbols: unicode symbolを入力するために使います。

** Isabelle入門にあたって

さて実際にIsabelleに入門しましょう。
ということで、上にも述べた通り公式Tutorialのprog-prove.pdfに入門に必要なことがきっちりまとまっているのでまずはこれを読んでください。
と言って以後はこのpdfを読んだことを前提にして進めてもいいのですが、実際にこう言って読む人はあんまりいないと思うので以下に超重要と思われることをかいつまんで説明しようと思います。
ただしここに述べるのは本当に最低限なので明日以降の記事を読んだりIsabelleに入門する人はprog-prove.pdfを一度読むことを強く勧めます。

** theoryの宣言

まずはIsabelle(jEdit)を起動します。
Isabelleのファイルは =.thy= という拡張子で保存し、1ファイルに1つのtheory(モジュール的なもの)を基本とします。

#+BEGIN_SRC text
  theory Test
  imports Main
  begin

  end
#+END_SRC

=theory= の後にはファイル名と同じ名前を書きます。
=imports Main= は =Main= というtheoryを読み込むことを表します。
=begin ... end= の間に証明を書いていきます。

** basic types and functions

先ほど =Main= をimportしたので、基本となる型がすでに定義されたものが読み込まれています。
例えば value "True" などと書いてみると、 "True" :: "bool" のように表示され、確かにbool型のコンストラクタとしてTrueが定義されているのが分かります。
他にも value "Suc 0" とかくと "Suc 0" :: "nat" と表示され、nat型のコンストラクタとして =0= や =Suc= というのが定義されているのが分かると思います。

さて簡単な関数を定義してみましょう。2つの自然数を加算するadd関数は、パターンマッチを用いて次のように定義できます。

#+BEGIN_SRC text
  fun add :: "nat ⇒ nat ⇒ nat" where
    "add 0 n = n"
    | "add (Suc m) n = Suc (add m n)"
#+END_SRC

ここで、 =⇒= は =\=>= と入力してください。jEditが勝手にユニコード文字に変換してくれます。以下の記事で入力の方法が分からないシンボルが出てきたらSymbolsパネルなどで確認してください。
また、上のコードのダブルクオーテーションには注意してください。IsabelleではIsabelleの項であることをダブルクオーテーションを付けて表現するのでコードの至るところがダブルクオーテーションまみれになります。

funキーワードで関数を定義できますが、この際にexhaustive checkが行われるのでパターンマッチが網羅的でないと怒られます。
正しく定義ができればaddの型が表示されます。ダメなときは黄色や赤のマーカーでメッセージが出ます。

リストなどもあります。 value "[0, Suc 0]" で "[0,Suc 0,Suc 0]" :: "nat list" のように表示されます。
なおリストのコンストラクタは Nil, Consですが、Isabelleの演算子定義により上の括弧とカンマによる記法が使えます。

** first proof

さてせっかくなので証明を書いてみましょう。
まずは雰囲気を知ってもらうために、次のような証明を眺めてください。

#+BEGIN_SRC text
  lemma add_r0: "add m 0 = m"
  apply (induction m)
  apply auto
  done
#+END_SRC

なんとなく解ると思いますが、 =add m 0 = m= が示したいことで、 =add_r0= がこの補題につける名前です。
そしてapplyの行でコマンドを適用し、終わればdoneと書きます。
applyにあるinductionというコマンドは帰納法を、autoは自動証明コマンドを表します。

** 定理証明界のfizzbuzz

さて証明の雰囲気を感じ取ってもらったところで証明を自力で書いてみます。
定理証明界のfizzbuzzこと[fn:2]リストを2回反転すると元に戻ることを示しましょう。

さてリストの反転関数revは次のように定まります。(型は面倒なのでかいてない)

#+BEGIN_SRC text
  fun app where
    "app Nil ys = ys"
    | "app (Cons x xs) ys = Cons x (app xs ys)"

  fun rev where
    "rev Nil = Nil"
    | "rev (Cons x xs) = app (rev xs) (Cons x Nil)"
#+END_SRC

実際に、value "[True, False]" などとして反転されることを確認してください。
示すべきことは次です。

#+BEGIN_SRC text
  theorem rev_rev_id: "rev (rev xs) = xs"
#+END_SRC

=rev_rev_id:= の名前の部分は省略しても構いません。
theoremとlemmaは同じ意味です。

*** まずは愚直に

さて、アウトプットパネルには示すべきゴールが書かれています。
xsについて帰納法を使ってみましょう。
帰納法を使うには、 =apply (induction xs)= と書きます。

ゴールが次のようになります。

#+BEGIN_SRC text
  goal (2 subgoals):
  1. rev (rev []) = []
  2. ⋀a xs. rev (rev xs) = xs ⟹ rev (rev (a # xs)) = a # xs
#+END_SRC

もしrevにprefixがついているならそれはすでに定義されているrevと名前がかぶっているからですが今は気にしなくてよいです。
さてこの2つを示さなくてはいけませんが、例えば自動証明コマンドであるautoを使って =apply auto= としてみてもまだ次のようなゴールが残ります。

#+BEGIN_SRC text
  goal (1 subgoal):
  1. rev (rev xs) = xs ⟹ rev (app (rev xs) [a]) = a # xs
#+END_SRC

いきなりこのゴールを示すのは難しいので、いくつかの補題を先に示しましょう。

*** 補題そして補題

app xs ysはxsとysを結合するという意味でしたが、これとrevの関係をまず示します。

#+BEGIN_SRC text
  lemma rev_app: "rev (app xs ys) = app (rev ys) (rev xs)"
#+END_SRC

さてこれに対してxsについての帰納法をしてみると、また詰まります。よってさらに補題をおきます。

#+BEGIN_SRC text
  lemma app_nil: "app xs Nil = xs"
#+END_SRC

これはxsについての帰納法でよいでしょう。
先ほどと同じようにして、

#+BEGIN_SRC text
  apply (induction xs)
  apply auto
  done
#+END_SRC

と、inductionとautoコマンドで証明が出来ます。
次の補題はappの結合性です。

#+BEGIN_SRC text
  lemma app_assoc: "app (app xs ys) zs = app xs (app ys zs)"
  apply (induction xs)
  apply auto
  done
#+END_SRC

そして =rev_app= に戻ります。

#+BEGIN_SRC text
  lemma rev_app: "rev (app xs ys) = app (rev ys) (rev xs)"
  apply (induction xs)
#+END_SRC

さて、ゴールが =rev (app [] ys) = app ys []= の形になりました。
左辺に対して先ほど示した =app_nil= を使うために、 =apply (simp add: app_nil)= と書きます。

simpコマンドは式を簡単にするコマンドですが、その時使って欲しい補題や定理の名前を追加することが出来ます。
これで1つめのゴールは終わりです。2つめのゴールも、先ほど示した =app_assoc= を使って =apply (simp add: app_assoc)= で終わりです。


さて、最初の定理に戻ります。
最初の定理は、今示した =rev_app= を使って示すことが出来ます。

*** 証明全体

今回の証明をまとめると次のようになります。

#+BEGIN_SRC text
  fun app where
    "app Nil ys = ys"
    | "app (Cons x xs) ys = Cons x (app xs ys)"

  fun rev where
    "rev Nil = Nil"
    | "rev (Cons x xs) = app (rev xs) (Cons x Nil)"

  lemma app_nil: "app xs Nil = xs"
  apply (induction xs)
  apply auto
  done

  lemma app_assoc: "app (app xs ys) zs = app xs (app ys zs)"
  apply (induction xs)
  apply auto
  done

  lemma rev_app: "rev (app xs ys) = app (rev ys) (rev xs)"
  apply (induction xs)
  apply (simp add: app_nil)
  apply (simp add: app_assoc)
  done

  theorem "rev (rev xs) = xs"
  apply (induction xs)
  apply simp
  apply (simp add: rev_app)
  done
#+END_SRC

*** structured proof

さて、上でも見たようにIsabelleは帰納法やsimp,autoといったコマンドを並べて証明を作っていきます。
しかしそれだけではなく、IsabelleはIsarと呼ばれる、より人間に読みやすい証明を書くための言語を用意しています。

これは今は細かく説明はしませんが、先ほどの証明をIsarを使って書いたものと見比べてみてください。

#+BEGIN_SRC text
  theorem "rev (rev xs) = xs"
  proof (induction xs)
    case Nil
    then show ?case
      apply simp
      done
  next
    case (Cons a xs)
    assume hyp: "rev (rev xs) = xs"

    have "rev (rev (a # xs)) = rev (rev (app [a] xs))" by simp
    also have "… = rev (app (rev xs) [a])" by simp
    also have "… = app [a] (rev (rev xs))" by (simp add: rev_app)
    also have "… = app [a] xs" by (simp add: hyp)
    finally show ?case by simp
  qed
#+END_SRC

** まとめ

駆け足でしたが以上でIsabelleの超基本は身につけてもらったことにして(超強引)、次からはより本格的な証明を書いていくことにします。
新しい概念などは逐次説明していきますが、あくまで雰囲気を理解してもらうのが目的ということでご容赦ください[fn:3]。


[fn:1] ProofGeneralはかつてサポートされていたけど切られてしまった…
[fn:2] これは私が勝手にそう呼んでいるのですが、実際「定理証明やったことある人なら誰でも書けると思われる」超基本問題としてfizzbuzz的な立ち位置にいると思っています。
[fn:3] という言い訳を済ませたのでこれでいくらでもぶっ飛ばしていいことになった



* IMP

今回から実際に実践的な証明をしながらIsabelleの解説をしていこうと思います。
そしてこの記事は一人computer scienceアドベントカレンダーなのでCSらしい話題を、ということで、
IMPのoperational semanticsの話でもしようと思います。

** IMP

IMPとはimperative languageの頭文字を取ったもので、natとboolを基本型にもつ簡単な手続き型言語です。
CSの教科書とかでよく見かけるやつです。
IMPの定義をし、そのevaluationを定めます。

ただし、IMPはチューリング完全なので評価は一般には停止しません。つまりプログラムを「評価」して結果を返すような関数は全域関数にはなりません。
このような評価を表す部分関数を定め、実際にこれがいい感じの性質をもつことを示していきます。

** States

まずはStateを定めます。これは変数名を受け取ってその値を返すもので、環境とも呼びます。
プログラムを実行する際に変数の値を記録するために必要になります。

#+BEGIN_SRC text
  section {* States *}

  type_synonym id = string
  type_synonym state = "id ⇒ nat"

  definition empty :: "state" where
    "empty _ = 0"

  no_syntax
    "_maplet"  :: "['a, 'a] ⇒ maplet"             ("_ /↦/ _")

  fun update :: "state ⇒ id ⇒ nat ⇒ state" ("_[_ ↦ _]" [80,80,80] 80) where
    "update st x n y = (if x = y then n else st y)"
#+END_SRC

=section= (=chapter= =subsection= =subsubsection=) はコードの区切り的なものを表すために使います。
それ自体はコメントと同じで証明には影響がありませんが、LaTeXに出力した時に実際にsectionとして扱われたりjEditのSidekickパネルにアウトラインの表示として使われたりするので付けておくと何かと便利です。

=type_synonym= は型に別名を付けます。

=defintiion= は定義を行います。
定義は関数と違って勝手に中を展開しません。このようにemptyを定義すると、 =empty_def= という定理が新たに追加されます。

=no_syntax= の部分は、演算子を取り除くために使っています。
以下のupdate関数で =st [x ↦ a]= という記法が使えるようにしたいのですが、このままでは =↦= という元々ある記法と衝突してパースが曖昧になってしまうので、今はどうせこの =↦= は使わないので演算子定義自体を解除してしまうために使っています。
もっといい方法があるような気がしますがよくわからないのでとりあえずこれで…

=update= 関数を定めるところでは、括弧の中で演算子を定義しています。
=_[_ ↦ _]= のアンダーバー部分が引数が来る場所で(順番は関数の引数の順番と同じ)、右の数値は結合優先度です。
演算子の優先度はDocumentationの main: What's in Main というやつに(HOLで定義されている演算子の一部は)書いてあるので参考にすると良いでしょう。

** Queryパネル

さて次に進む前にIsabelleのQueryパネルの解説をしておきます。
Queryパネルでは定理の検索などが出来ます。
例えば、先ほどemptyの定義をしたので =empty_def= という定理が追加されているので、これを検索してみましょう。

Find:の部分に =name:empty_def= と打ち込むとtheoremがずらずら表示されると思います。
多くて見にくい時は、さらに =name:[theoryの名前]= などとすると特定のtheoryで定義されたtheoremだけの検索などが出来ます。

検索結果として =empty_def: empty ?uu = 0= みたいなのが表示されていればOKです。
=?uu= というのは自由変数で、定理に出現する自由変数は?をprefixにつけて表します。

他にも、定理を名前ではなくステートメントで検索できます。
例えば "_ + _" などとしてみましょう。(ダブルクオーテーションは必須です)
すると _ + _ の形を含む定理が検索できます。



** Syntax

さて、arithmetic expressionとboolean expressionを定義しましょう。

#+BEGIN_SRC text
  datatype aexp = ANum nat | AId id | APlus aexp aexp | AMinus aexp aexp | AMult aexp aexp
  datatype bexp = BTrue | BFalse | BEq aexp aexp | BLeq aexp aexp | BAnd bexp bexp | BNot bexp
#+END_SRC

データ型はdatatypeで定義します。Haskellと同じような感じで、コンストラクタの後に引数の型を並べて書いたものを縦棒で繋ぎます。コンストラクタも型も大文字でも小文字でも自由です。
ところで、説明していませんでしたがIsabelleでは型変数はクオートを付けて前置するきまりになっています。
ので、例えばリストは

#+BEGIN_SRC text
  datatype 'a list = nil | cons 'a "'a list"
#+END_SRC

とやって定義します。ここで、consの第二引数にはダブルクオーテーションが必須なことに注意してください。('a listを1つの項として扱いたいので)

datatypeによって型を定義するとコンストラクタだけでなく、構造帰納法などが同時に生成されます。
このことは後で説明します。

** Evaluation of AExp, BExp

さてevaluationを定義します。
本来ならばaexp,bexpのevaluationも帰納的な関係として定めるのですが、aexp,bexpは普通に関数として扱ってしまうことができるので
ここでは手を抜いてそうしてしまいます。

#+BEGIN_SRC text
  subsection {* Evaluation *}

  fun aeval :: "state ⇒ aexp ⇒ nat" where
    "aeval st (ANum n) = n"
    | "aeval st (AId x) = st x"
    | "aeval st (APlus a1 a2) = aeval st a1 + aeval st a2"
    | "aeval st (AMinus a1 a2) = aeval st a1 - aeval st a2"
    | "aeval st (AMult a1 a2) = aeval st a1 * aeval st a2"

  fun beval :: "state ⇒ bexp ⇒ bool" where
    "beval st BTrue = True"
    | "beval st BFalse = False"
    | "beval st (BEq a1 a2) = (aeval st a1 = aeval st a2)"
    | "beval st (BLeq a1 a2) = (aeval st a1 ≤ aeval st a2)"
    | "beval st (BNot b) = (¬ beval st b)"
    | "beval st (BAnd b1 b2) = (beval st b1 ∧ beval st b2)"

  fun bool_to_bexp :: "bool ⇒ bexp" where
    "bool_to_bexp b = (if b then BTrue else BFalse)"
#+END_SRC

aeval,bevalはstate(変数の情報)を受け取ってaexp,bexpをそれぞれnat,boolになるように計算を行います。
ついでに =bool_to_bexp= を定義しました。あとで使います。

** Commands

さてaexp, bexpを定義したところでIMPの本体であるところの命令たちを定義しましょう。
これをコマンドとよび、変数代入、IF文、WHILE文などがあります。

#+BEGIN_SRC text
  section {* Commands *}

  subsection {* Syntax *}

  datatype com = CSkip | CAssign id aexp | CSeq com com | CIf bexp com com | CWhile bexp com

  notation
    CSkip ("SKIP") and
    CAssign ("_ ::= _" [50,50] 90) and
    CSeq (infixr ";;" 30) and
    CIf ("IF _ THEN _ ELSE _" 80) and
    CWhile ("WHILE _ DO _" 90)
#+END_SRC

またしてもdatatypeによってcomを定義しています。
さて、コンストラクタを演算子として使いたいので、そのためにnotationという記法で新たな演算子を定義しています。

演算子はinfix operatorとそうでないものがあり、infix operatorは =infix, infixr, infixl= と演算子優先度を指定して定めます。
例えばこのようなnotationを定めることで、

#+BEGIN_SRC text
  WHILE BLeq (AId ''X'') (ANum 0) DO
    IF BTrue THEN
      ''X'' ::= ANum 1 ;;
      ''Y'' ::= ANum 10
    ELSE
      SKIP
#+END_SRC

のような記述ができるようになります。

** Operational semantics

さていよいよcommandの評価を行えるようにします。
評価は関数ではなく関係として定めます。

#+BEGIN_SRC text
  section {* Small-step operational semantics *}

  subsection {* Definition *}

  inductive csmall :: "com ⇒ state ⇒ com ⇒ state ⇒ bool" ("<_,_> ⟶ <_,_>" [10,10,10,10] 90) where
    S_AssNum: "<x ::= ANum n , st> ⟶ <SKIP , st [x ↦ n]>"
  | S_AssStep: "<x ::= a , st> ⟶ <x ::= ANum (aeval st a) , st>"
  | S_SeqSkip: "<SKIP ;; c , st> ⟶ <c,st>"
  | S_SeqStep: "<c1,st> ⟶ <c1',st'> ⟹ <c1 ;; c2 , st> ⟶ <c1' ;; c2 , st'>"
  | S_IfTrue: "<IF BTrue THEN c1 ELSE c2 , st> ⟶ <c1 , st>"
  | S_IfFalse: "<IF BFalse THEN c1 ELSE c2 , st> ⟶ <c2 , st>"
  | S_IfStep: "<IF b THEN c1 ELSE c2 , st> ⟶ <IF (bool_to_bexp (beval st b)) THEN c1 ELSE c2 , st>"
  | S_WHILE: "<WHILE b DO c , st> ⟶ <IF b THEN c ;; WHILE b DO c ELSE SKIP , st>"

  section {* Big-step operational semantics *}

  subsection {* Definition *}

  inductive cbig :: "com ⇒ state ⇒ state ⇒ bool" ("<_,_> ⇓ _" [10,10,10] 70) where
    B_Skip: "<SKIP,st> ⇓ st"
  | B_Ass: "<x ::= a , st> ⇓ (st [x ↦ aeval st a])"
  | B_Seq: "⟦ <c1,st1> ⇓ st2; <c2,st2> ⇓ st3 ⟧ ⟹ <c1 ;; c2 , st1> ⇓ st3"
  | B_IfTrue: "⟦ beval st b = True; <c1,st> ⇓ st' ⟧ ⟹ <IF b THEN c1 ELSE c2 , st> ⇓ st'"
  | B_IfFalse: "⟦ beval st b = False; <c2,st> ⇓ st' ⟧ ⟹ <IF b THEN c1 ELSE c2 , st> ⇓ st'"
  | B_WhileFalse: "beval st b = False ⟹ <WHILE b DO c , st> ⇓ st"
  | B_WhileStep: "⟦ beval st b = True; <c,st> ⇓ st'; <WHILE b DO c , st'> ⇓ st'' ⟧ ⟹ <WHILE b DO c , st> ⇓ st''"
#+END_SRC

帰納的な関係をinductiveキーワードで定めています。
inductiveは帰納的な関係を定義し、さらに構造帰納法などを生成してくれます。

inductiveが何をしているのかよくわからんという人のために、csmallの定義は書き下すと次のようになります。
(あんまり変わってないのでこれでも分からないかもしれないけどまぁそのへんは雰囲気で)

#+BEGIN_SRC text
  Def. com×state上の関係 --> を次のような規則からなるものとして定める。
  (S_AssNum)  <x ::= n , st> --> <SKIP , st[x := n]>
  (S_AssStep) <x ::= a , st> --> <x ::= aeval st a , st>
  (S_SeqSkip) <SKIP ;; c , st> --> <c,st>
  (S_SeqStep) <c1,st> --> <c1',st'> ならば、 <c1 ;; c2 , st> --> <c1' ;; c2 , st'>
  (S_IfTrue)  <IF true THEN c1 ELSE c2 , st> --> <c1,st>
  (S_IfFalse) <IF false THEN c1 ELSE c2 , st> --> <c2,st>
  (S_IfStep)  <IF b THEN c1 ELSE c2 , st> --> <IF beval st b THEN c1 ELSE c2 , st>
  (S_WHIE)    <WHILE b DO c , st> --> <IF b THEN (c ;; WHILE b DO c ELSE SKIP) , st>
#+END_SRC

csmallはsmall-step、cbigはbig-stepの評価を定めています。
それぞれ演算子定義により、 =<c,st> --> <c',st'>= や =<c,st1> ⇓ st2= などと書けるようになっていることが分かるでしょうか。




** Deterministic

さて順番が多少前後しますが、示したい定理を先に述べておきます。
1つめのゴールとしては、evaluationのdeterministicがあります。
先ほど定めたcbigは単なる関係ですが =<c,st1> ⇓ st2= が入力 =c,st1= に対して部分関数になること(結果が存在すれば1つになる)を示すのがここでの目的です。

#+BEGIN_SRC text
  lemma cbig_deterministic: "⟦ <c,st> ⇓ st'; <c,st> ⇓ st'' ⟧ ⟹ st' = st''"
#+END_SRC

ここで、 =⟦ P1; P2 ⟧ ⟹ Q= は =P1 ⟹ P2 ⟹ Q= と同じです(仮定が複数ある時の記法)。
さてこれの証明について考えてみると、 =<c,st> ⇓ st'_= についての帰納法がよさそうです。このときこのまま帰納法を行うとゴールにcやstについての記法などが乱れ飛んで散らかるので、先に補題の形で =<c,st1> ⇓ st2= のcが具体的な形の時に何が言えるかを述べておきます。
(このように、帰納法をそのまま使うと散らかるからよくない、みたいな感覚は定理証明では意外と重要です。散らかりすぎると自動証明が証明を諦めてしまったりします)

** Coherent lemmas

#+BEGIN_SRC text
  subsection {* Coherent lemmas *}

  lemma coh_B_Skip:
    assumes "<SKIP,st> ⇓ st'"
    shows "st = st'"
  using cbig.cases [OF assms] by auto
#+END_SRC

最初はSKIPのケースです。 =<SKIP,st> ⇓ st\'\=




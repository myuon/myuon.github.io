---
title: ぴよぴよ
date: 2017-11-10T01:02:06+09:00
draft: true
toc: true
---

* Isabelle/HOLを用いた証明

今回から実際に実践的な証明をしながらIsabelleの解説をしていこうと思います。
そしてこの記事は一人computer scienceアドベントカレンダーなのでCSらしい話題を、ということで、
IMPのoperational semanticsの話でもしようと思います。

** IMPについて

IMPとはimperative languageの頭文字を取ったもので、natとboolを基本型にもつ簡単な手続き型言語です。
CSの教科書とかでよく見かけるやつです。
IMPの定義をし、そのevaluationを定めます。

ただし、IMPはチューリング完全なので評価は一般には停止しません。つまりプログラムを「評価」して結果を返すような関数は全域関数にはなりません。
このような評価を表す部分関数(関係)を定め、実際にこれがいい感じの性質をもつことを示していきます。

** 0. States

IMPの定義を行う前の準備。IMPは変数を扱うことができるので変数名を処理するための型が必要になるのと、プログラムの実行には実際に各変数の値を記録したもの(環境の一種)が必要になるのでそれらを定義する。

#+BEGIN_SRC text
  section {* States *}

  type_synonym id = string
  type_synonym state = "id ⇒ nat"

  definition empty :: "state" where
    "empty _ = 0"

  no_syntax
    "_maplet"  :: "['a, 'a] ⇒ maplet"             ("_ /↦/ _")

  fun update :: "state ⇒ id ⇒ nat ⇒ state" ("_[_ ↦ _]" [80,80,80] 80) where
    "update st x n y = (if x = y then n else st y)"
#+END_SRC

sectionコマンドは証明には影響を与えないが、Sidekickにsectionとして表示されたりLaTeXに出力すると実際に節として扱われたりするもの。chapter, subsectio, subsubsectionなどもある。

さて、 ~id~ で変数名を表すことにし、さらに環境を表す ~state~ を定めた。
ここでは ~id~ として ~string~ を、 ~state~ としてidを受け取ってnatを返す関数を使うことにした。(変数に格納される値は常にnatである)

Isabelleで文字列リテラルは ~''hoge''~ と、シングルクオート2つで囲って表現する[fn:4]。

さてここではupdateというstateを更新する関数を定義しているが、その前になにやらno_syntaxという箇所がある。
これは、update関数を演算子として ~st [x ↦ n]~ のように書きたいのだが、この記法がすでにある ~_maplet~ という記法と被ってしまうため既存の記法を解除するためのものである。
このように記法が被った場合、すでにある演算子の定義を調べ(jEditならCtrlを押しながらクリックとかで定義箇所に飛べる)、それをno_syntaxやno_notationで解除することができる。

** 1. Arithmetic and Boolean Expression

さて、arithmetic expressionとboolean expressionを定義しよう。

arithmetic expressionはnat型のtermで、数値リテラル、(nat型の)変数、あるいはaexp同士の和・差・積のいずれか。
boolean expressionはbool型のtermで、true、false、aexp同士の比較、bexpのかつや否定をとったもののいずれか。

#+BEGIN_SRC text
  section {* Arithmetic and Boolean Expressions *}

  subsection {* Syntax *}

  datatype aexp = ANum nat | AId id | APlus aexp aexp | AMinus aexp aexp | AMult aexp aexp
  datatype bexp = BTrue | BFalse | BEq aexp aexp | BLeq aexp aexp | BAnd bexp bexp | BNot bexp
#+END_SRC

** 2. Evaluation of AExp, BExp

さてaexp, bexpのevaluationを定義しよう。
aexp, bexpの評価は常に可能(常に有限ステップで停止する関数がかける)ので大人しくfunで関数として定義することにする。

#+BEGIN_SRC text
  subsection {* Evaluation *}

  fun aeval :: "state ⇒ aexp ⇒ nat" where
    "aeval st (ANum n) = n"
    | "aeval st (AId x) = st x"
    | "aeval st (APlus a1 a2) = aeval st a1 + aeval st a2"
    | "aeval st (AMinus a1 a2) = aeval st a1 - aeval st a2"
    | "aeval st (AMult a1 a2) = aeval st a1 * aeval st a2"

  fun beval :: "state ⇒ bexp ⇒ bool" where
    "beval st BTrue = True"
    | "beval st BFalse = False"
    | "beval st (BEq a1 a2) = (aeval st a1 = aeval st a2)"
    | "beval st (BLeq a1 a2) = (aeval st a1 ≤ aeval st a2)"
    | "beval st (BNot b) = (¬ beval st b)"
    | "beval st (BAnd b1 b2) = (beval st b1 ∧ beval st b2)"

  fun bool_to_bexp :: "bool ⇒ bexp" where
    "bool_to_bexp b = (if b then BTrue else BFalse)"
#+END_SRC

aeval, bevalともに評価を行う際に変数の値を参照したりする可能性があるのでstateを引数として渡している。
ついでに =bool_to_bexp= を定義しておいた。後で使う。

** 3. Commands

さて次にcommandを定義する。

これはIMPの「命令」や「文」にあたるもので、変数の代入、If文、While文などが用意されている。

#+BEGIN_SRC text
  section {* Commands *}

  subsection {* Syntax *}

  datatype com = CSkip | CAssign id aexp | CSeq com com | CIf bexp com com | CWhile bexp com

  notation
    CSkip ("SKIP") and
    CAssign ("_ ::= _" [50,50] 90) and
    CSeq (infixr ";;" 30) and
    CIf ("IF _ THEN _ ELSE _" 80) and
    CWhile ("WHILE _ DO _" 90)
#+END_SRC

comを定義した後、notationによって各コンストラクタをよりそれらしいnotationで記述できるようにしている。
このように定義しておくと、例えば以下のような記述ができるようになる。

#+BEGIN_SRC text
  WHILE BLeq (AId ''X'') (ANum 0) DO
    IF BTrue THEN
      ''X'' ::= ANum 1 ;;
      ''Y'' ::= ANum 10
    ELSE
      SKIP
#+END_SRC

** 4. Operational semantics

さていよいよcommandの評価を行えるようにする。

commandにはWHILEが含まれていることからも分かる通り無限ループが書けるので、一般に評価は停止しない。
このため、「commandを実行したら(有限ステップで停止し)rという結果になった」ということを表現するための関係を定義する。

あるいは、これはevalという部分関数のグラフだと思っても良いが、domain上でのwell-definednessは後にeval_deterministicという形で示すまでは単なる関係である。

*** small-step vs big-step

これは直接IMPとは関係のない話だけれどして念の為ここで説明しておく。

operational semanticsとは「評価」や「簡約」と言った操作を定めるが、この定め方としてsmall-stepまたはbig-stepという手法が使われる。
small-stepとは、与えられたtermの次のステップを具体的に与えるようなもので、big-stepとは与えられたtermのsubtermを評価した結果を用いて次のステップを与えるようなもの。
(これもだいぶ怪しい説明な気がするがなんて言ったらいいのかヨクワカラナイ)

small-stepは1ステップ分を定義してそれを順次繋いでいくという比較的直観に沿った与え方である。
例えば ~M~ という項を評価すると ~r~ という結果になるような場合、 ~M -> M1 -> M2 -> ... -> r~ のようなステップを1つ1つ進んでいくような仕方で簡約が進むやり方(ここでの矢印1つ1つ)がsmall-stepである。

対してbig-stepはrecursive functionの定義のように、 ~eval(M)~ の定義の中で ~eval(M')~ (M'はMのsubterm)なる結果を用いることができる。

small-stepとbig-stepのどちらがよいというようなものではなく、大抵の場合は片方を定めたらもう一方も簡単に導出でき、しかも同値である(small-stepを繰り返したものとbig-stepは関係として一致する)ことが示せることが多い。
(極稀に一方では定めにくい言語があるがそうそう遭遇するものではないと思う)


というわけで今回も、IMPのoperational semanticsをsmall-stepとbig-stepの両方で定め、それが同値になることを後々に示すことになる。

*** コード

#+BEGIN_SRC text
  section {* Small-step operational semantics *}

  subsection {* Definition *}

  inductive csmall :: "com ⇒ state ⇒ com ⇒ state ⇒ bool" ("<_,_> ⟶ <_,_>" [10,10,10,10] 90) where
    S_AssNum: "<x ::= ANum n , st> ⟶ <SKIP , st [x ↦ n]>"
  | S_AssStep: "<x ::= a , st> ⟶ <x ::= ANum (aeval st a) , st>"
  | S_SeqSkip: "<SKIP ;; c , st> ⟶ <c,st>"
  | S_SeqStep: "<c1,st> ⟶ <c1',st'> ⟹ <c1 ;; c2 , st> ⟶ <c1' ;; c2 , st'>"
  | S_IfTrue: "<IF BTrue THEN c1 ELSE c2 , st> ⟶ <c1 , st>"
  | S_IfFalse: "<IF BFalse THEN c1 ELSE c2 , st> ⟶ <c2 , st>"
  | S_IfStep: "<IF b THEN c1 ELSE c2 , st> ⟶ <IF (bool_to_bexp (beval st b)) THEN c1 ELSE c2 , st>"
  | S_WHILE: "<WHILE b DO c , st> ⟶ <IF b THEN c ;; WHILE b DO c ELSE SKIP , st>"

  section {* Big-step operational semantics *}

  subsection {* Definition *}

  inductive cbig :: "com ⇒ state ⇒ state ⇒ bool" ("<_,_> ⇓ _" [10,10,10] 70) where
    B_Skip: "<SKIP,st> ⇓ st"
  | B_Ass: "<x ::= a , st> ⇓ (st [x ↦ aeval st a])"
  | B_Seq: "⟦ <c1,st1> ⇓ st2; <c2,st2> ⇓ st3 ⟧ ⟹ <c1 ;; c2 , st1> ⇓ st3"
  | B_IfTrue: "⟦ beval st b = True; <c1,st> ⇓ st' ⟧ ⟹ <IF b THEN c1 ELSE c2 , st> ⇓ st'"
  | B_IfFalse: "⟦ beval st b = False; <c2,st> ⇓ st' ⟧ ⟹ <IF b THEN c1 ELSE c2 , st> ⇓ st'"
  | B_WhileFalse: "beval st b = False ⟹ <WHILE b DO c , st> ⇓ st"
  | B_WhileStep: "⟦ beval st b = True; <c,st> ⇓ st'; <WHILE b DO c , st'> ⇓ st'' ⟧ ⟹ <WHILE b DO c , st> ⇓ st''"
#+END_SRC

定め方自体はごく標準的な仕方で取った。
面倒なので逐一説明はしないけど(よく知らないって人には申し訳ないです)それぞれWHILEの評価をどうやっているかに注目しておくといいんじゃなかろうかと思う。

small-stepの方では ~WHILE b DO c -> IF b THEN (c ;; WHILE b DO c ELSE SKIP)~ とやっているのに対して、
big-stepの方では ~WHILE b DO c~ の ~b~ をまず評価し、それがfalseなら何もしない、trueなら ~c~ の実行と ~WHILE b DO c~ の実行を順次帰納的に行うことにしている。

big-stepな方では、 ~<c,st1> ⇓ st2~ と 「cをst1の下で評価したら停止してst2になる」ことが同値になる(関係の中に停止性が含まれている)のでこのような定義になっていることに注意しよう。

** 5. Deterministic

さて実際の証明とは前後するが、ここで示したい定理のうちの1つを述べる。

#+BEGIN_SRC text
  lemma cbig_deterministic: "⟦ <c,st> ⇓ st'; <c,st> ⇓ st'' ⟧ ⟹ st' = st''"
#+END_SRC

これは関係cbigが部分関数であること(値を返す入力に対してはwell-definedであること)を言っている。
これを示すためにはいくつか補題が必要になるので以下ではそれを先に示していく。

** 6. Coherent lemmas

*** SKIP

#+BEGIN_SRC text
  subsection {* Coherent lemmas *}

  lemma coh_B_Skip:
    assumes "<SKIP,st> ⇓ st'"
    shows "st = st'"
  using cbig.cases [OF assms] by auto
#+END_SRC

始めの補題はSKIPについてで、 ~<SKIP,st> ⇓ st'~ ならば ~st = st'~ というものである。
直観的には明らかであろうし、証明も場合分けをするだけで済む。

*** Ass

#+BEGIN_SRC text
  lemma coh_B_Ass:
    assumes "<x ::= a , st> ⇓ st'"
    shows "st' = st [x ↦ aeval st a]"
  using cbig.cases [OF assms] by auto
#+END_SRC

次は変数への代入。これも簡単なので省略。

*** Seq

#+BEGIN_SRC text
  lemma coh_B_Seq:
    assumes "<c1 ;; c2 , st> ⇓ st'"
    obtains st'' where "<c1 , st> ⇓ st''" and "<c2 , st''> ⇓ st'"
#+END_SRC

~<c1 ;; c2,st> ⇓ st'~ ならば、 ~c1~ を実行すると評価が停止し、さらにその後 ~c2~ を実行すると ~st'~ の状態になって評価が停止するということが言えるはずである。
上では後々の便利さのために ~obtains ... where ...~ で補題を宣言しているが、証明は存在量化を使った命題を示すという感じでやる。

#+BEGIN_SRC text
    proof-
      have "<c1 ;; c2 , st> ⇓ st' ⟹ ∃st''. (<c1 , st> ⇓ st'') ∧ (<c2 , st''> ⇓ st')"
	by (erule cbig.cases, auto)
      then obtain st'' where "<c1 , st> ⇓ st''" and "<c2 , st''> ⇓ st'"
	by (simp add: assms, auto)
      then show ?thesis
	using that by blast
    qed
#+END_SRC

証明の内容自体は場合分けくらいしかしてないのでよいと思う。

*** If

~<IF b THEN c1 ELSE c2 , st> ⇓ st'~ のときにst'がどうなるかは ~b~ が何になるかによって変わるのでここでは2つ補題をおく。

#+BEGIN_SRC text
  lemma coh_B_IfTrue:
    assumes "<IF b THEN c1 ELSE c2 , st> ⇓ st'"
    and "beval st b = True"
    shows "<c1 , st> ⇓ st'"
  proof-
    have "<IF b THEN c1 ELSE c2 , st> ⇓ st' ⟹ <c1,st> ⇓ st'"
      apply (cases rule: cbig.cases, auto)
      using assms(2) apply auto
      done
    then show ?thesis by (simp add: assms(1))
  qed

  lemma coh_B_IfFalse:
    assumes "<IF b THEN c1 ELSE c2 , st> ⇓ st'"
    and "beval st b = False"
    shows "<c2 , st> ⇓ st'"
  proof-
    have "<IF b THEN c1 ELSE c2 , st> ⇓ st' ⟹ <c2,st> ⇓ st'"
      apply (cases rule: cbig.cases, auto)
      using assms(2) apply auto
      done
    then show ?thesis by (simp add: assms(1))
  qed
#+END_SRC

見たままではあるが、bがtrueになるときはc1が実行され、bがfalseになるときはc2が実行される。
ところでbはboolではなくbexpだったので、場合分けは ~beval st b~ によって行うことに注意。

*** While

さて最後にWHILEである。
WHILEもIFと同じく与えられた条件が成り立つかによって場合分けを行う。

#+BEGIN_SRC text
  lemma coh_B_WhileFalse:
    assumes "beval st b = False"
    and "<WHILE b DO c , st> ⇓ st'"
    shows "st = st'"
  proof-
    have "<WHILE b DO c , st> ⇓ st' ⟹ st = st'"
      apply (erule cbig.cases, auto)
      apply (simp add: assms(1))
      done
    then show ?thesis by (simp add: assms(2))
  qed

  lemma coh_B_WhileStep:
    assumes "beval st b = True"
    and "<WHILE b DO c , st> ⇓ st''"
    obtains "st'" where "<c,st> ⇓ st'" and "<WHILE b DO c , st'> ⇓ st''"
  proof-
    have "<WHILE b DO c , st> ⇓ st'' ⟹ ∃st'. (<c,st> ⇓ st') ∧ (<WHILE b DO c , st'> ⇓ st'')"
      by (erule cbig.cases, auto simp add: assms(1))
    then obtain "st'" where "<c,st> ⇓ st'" and "<WHILE b DO c , st'> ⇓ st''"
      by (simp add: assms, auto)
    then show ?thesis
      using that by blast
  qed
#+END_SRC

これも場合分けやるだけ。

** 7. Proof of Determinism

いよいよ目標だったcbigのDeterminismを示そう。

#+BEGIN_SRC text
  subsection {* Determinism *}

  lemma cbig_deterministic: "⟦ <c,st> ⇓ st'; <c,st> ⇓ st'' ⟧ ⟹ st' = st''"
  proof-
    have "<c,st> ⇓ st' ⟹ (∀st''. (<c,st> ⇓ st'') ⟶ st' = st'')"
      apply (induction rule: cbig.induct)
        apply (simp add: coh_B_Skip)
        apply (rule, rule) using coh_B_Ass apply auto[1]
        apply (rule, rule, erule coh_B_Seq, simp)
        using coh_B_IfTrue apply blast
        using coh_B_IfFalse apply blast
        apply (simp add: coh_B_WhileFalse)
        by (metis coh_B_WhileStep)
    then show "⟦ <c,st> ⇓ st'; <c,st> ⇓ st'' ⟧ ⟹ st' = st''"
      by simp
  qed
#+END_SRC

といっても証明自体は上で示した補題を使うだけなので簡単。
ちなみにこの証明は、inductionの行以外は全てsledgehammerで導出しているのでマウスでボタンをぽちぽちやっているだけで証明が終わる。

さて、上のcoherent lemmaでは場合分けしか行わなかったが、実際にこの補題は必要なのだろうか？と疑問に思うかもしれない。
やってみると分かるのだが、この証明を上のような補題なしで直接行うのはかなり困難である。caseによる場合分けが必要であることがわかっても、今示そうとしている命題はかなり複雑なので解の探索が上の補題に比べてずっと難しくなる。

補題をおくということは仮定を減らすことでもあり、本当に必要な仮定だけにしないと現実的な時間で探索が終わらないということはよくあるので、このように適切な補題をおくのは(証明が再利用できるだけでなく)大切なことである。

** 8. Small-step & Big-step

次に目標となる定理は次である。

#+BEGIN_SRC text
  theorem "<c,st> ⟶* <SKIP,st'> ⟷ <c,st> ⇓ st'"
#+END_SRC

これはsmall-stepとbig-stepの関係を表す定理である。
(ここで、 ~<c,st> ⟶* <SKIP,st'>~ はcsmallを何回かしたやつ、みたいな意味で、まだ定義していないが下で定める。)

以下でこの定理を示していく。

** 9. Small-step long reduction

csmallを複数回適用した、ということを表す関係を ~<_,_> ⟶* <_,_>~ でかいて、次のように定める。

#+BEGIN_SRC text
  subsubsection {* small-step long reduction *}

  inductive csmall_long ("<_,_> ⟶* <_,_>") where
    SL_refl: "<c,st> ⟶* <c,st>"
  | SL_trans1: "⟦ <c,st> ⟶ <c',st'>; <c',st'> ⟶* <c'',st''> ⟧ ⟹ <c,st> ⟶* <c'',st''>"

  lemma SL_trans: "⟦ <c,st> ⟶* <c',st'>; <c',st'> ⟶* <c'',st''> ⟧ ⟹ <c,st> ⟶* <c'',st''>"
  apply (induction arbitrary: c'' st'' rule: csmall_long.induct)
  apply simp
  apply (blast intro: SL_trans1)
  done

  lemma SL_SeqStep: "<c1,st> ⟶* <c1',st'> ⟹ <c1;;c2,st> ⟶* <c1';;c2,st'>"
  apply (induction arbitrary: c2 rule: csmall_long.induct)
  apply (rule SL_refl)
  using SL_trans1 S_SeqStep by blast
#+END_SRC

csmall_longは見ての通り、reflexitivityとtransitivityを使って定義しているが、これは次のように定めることと同値である。

#+BEGIN_SRC text
    inductive csmall_long ("<_,_> ⟶* <_,_>") where
      SL_refl: "<c,st> ⟶* <c,st>"
    | SL_trans: "⟦ <c,st> ⟶* <c',st'>; <c',st'> ⟶* <c'',st''> ⟧ ⟹ <c,st> ⟶* <c'',st''>"
#+END_SRC

前者の定義ではtransitivityが1ステップとnステップの組み合わせで書かれているのに対し、後者ではnステップとnステップの組み合わせで書かれている。
これらが同値であることも示せるが、上のような定義を採用したのは帰納法を適用する際に若干楽になるからである。

代わりにnステップ同士のtransitivityは ~SL_trans~ として改めて示している。
 ~SL_SeqStep~ はあとで必要になる補題である。

** 10. Proof of Small-step & Big-step

さて目標となる定理を示そう。

#+BEGIN_SRC text
  lemma csmall_step: "⟦ <c,st> ⟶ <c',st'>; <c',st'> ⇓ st'' ⟧ ⟹ <c,st> ⇓ st''"
  apply (induction arbitrary: st'' rule: csmall.induct)
    apply (metis B_Ass aeval.simps(1) coh_B_Skip)
    using B_Ass coh_B_Ass apply fastforce
    using B_Seq B_Skip apply blast
    apply (meson B_Seq coh_B_Seq)
    apply (simp add: B_IfTrue)
    apply (simp add: B_IfFalse)
    apply (metis B_IfFalse B_IfTrue beval.simps(1) beval.simps(2) bool_to_bexp.simps coh_B_IfFalse coh_B_IfTrue)
    apply (metis B_WhileFalse B_WhileStep coh_B_IfFalse coh_B_IfTrue coh_B_Seq coh_B_Skip)
    done

  lemma csmall_steps: "⟦ <c,st> ⟶* <c',st'>; <c',st'> ⇓ st'' ⟧ ⟹ <c,st> ⇓ st''"
  apply (induction arbitrary: st'' rule: csmall_long.induct)
  apply simp
  apply (simp add: csmall_step)
  done
#+END_SRC

初めに、small-stepしてからbig-stepしたものは全体としてbig-stepしたものになるという補題を示した。
(ふわっとした説明しかできないけどなんて言ったらいいのかよくわからないので)

#+BEGIN_SRC text
  theorem "<c,st> ⟶* <SKIP,st'> ⟷ <c,st> ⇓ st'"
  proof rule
    assume hyp: "<c,st> ⟶* <SKIP,st'>"
    have "<SKIP,st'> ⇓ st'" by rule
    then show "<c,st> ⇓ st'"
      by (rule csmall_steps [OF hyp])
  next
    show "<c,st> ⇓ st' ⟹ <c,st> ⟶* <SKIP,st'>"
      apply (erule cbig.inducts)
      apply (simp add: SL_refl)
      apply (meson S_AssNum S_AssStep csmall_long.simps)
      using SL_SeqStep SL_trans SL_trans1 S_SeqSkip apply blast
      apply (metis SL_trans1 S_IfStep S_IfTrue bool_to_bexp.simps)
      apply (metis S_IfFalse S_IfStep bool_to_bexp.simps csmall_long.simps)
      apply (metis SL_refl SL_trans1 S_IfFalse S_IfStep S_WHILE bool_to_bexp.simps)
      proof-
        fix st b c st' st''
        assume b: "beval st b = True"
        and "<c,st> ⇓ st'"
        and h: "<c,st> ⟶* <SKIP,st'>"
        and "<WHILE b DO c,st'> ⇓ st''"
        and j: "<WHILE b DO c,st'> ⟶* <SKIP,st''>"
      
        have "<WHILE b DO c,st> ⟶* <IF b THEN c ;; WHILE b DO c ELSE SKIP,st>"
          using SL_refl SL_trans1 S_WHILE by blast
        moreover have "<IF b THEN c ;; WHILE b DO c ELSE SKIP,st> ⟶* <c ;; WHILE b DO c , st>"
          using b by (metis S_IfStep S_IfTrue bool_to_bexp.simps csmall_long.simps)
        moreover have "<c ;; WHILE b DO c , st> ⟶* <SKIP ;; WHILE b DO c , st'>"
          by (rule SL_SeqStep, rule h)
        moreover have "<SKIP ;; WHILE b DO c , st'> ⟶* <WHILE b DO c , st'>"
          by (rule, rule, rule)
        moreover have "<WHILE b DO c , st'> ⟶* <SKIP,st''>"
          by (rule j)
        ultimately show "<WHILE b DO c,st> ⟶* <SKIP,st''>"
          using SL_trans by blast
      qed
  qed
#+END_SRC


順に見ていこう。

まず ~<c,st> ⟶* <SKIP,st'> ⟹ <c,st> ⇓ st'~ は、 ~<SKIP,st'> ⇓ st'~ と先ほど示したcsmall_stepsにより示される。

~<c,st> ⇓ st' ⟹ <c,st> ⟶* <SKIP,st'>~ の方は、 ~<c,st> ⇓ st'~ についての場合分けを行う。
場合分けはWHILE_true以外は明らかで、WHILE_trueのところは次のような式変形を示しているのが分かると思う:

#+BEGIN_SRC text
  <WHILE b DO c,st>
  ⟶* <IF b THEN c ;; WHILE b DO c ELSE SKIP,st>
  ⟶* <c ;; WHILE b DO c,st>
  ⟶* <SKIP ;; WHILE b DO c,st'>
  ⟶* <WHILE b DO c,st'>
  ⟶* <SKIP,st''>
#+END_SRC


* Footnotes

[fn:1] ProofGeneralはかつてサポートされていたけど切られてしまった…

[fn:2] シリーズ後半でこれにも触れます

[fn:3] と私が勝手に呼んでるけど実際に入門に適したいい問題だと思う

[fn:4] ダブルクオーテーションが取られてしまっているので致し方ないのだろうけど不格好だよね


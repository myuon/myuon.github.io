<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Rust on The curse of λ</title>
    <link>https://myuon.github.io/tags/rust/</link>
    <description>Recent content in Rust on The curse of λ</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-jp</language>
    <lastBuildDate>Sat, 29 Feb 2020 19:37:36 +0900</lastBuildDate>
    
      <atom:link href="https://myuon.github.io/tags/rust/index.xml" rel="self" type="application/rss+xml" />
    
    
      <item>
        <title>GoとRustの言語比較記事を書くのが流行ってるらしい</title>
        <link>https://myuon.github.io/posts/golang-and-rust/</link>
        <pubDate>Sat, 29 Feb 2020 19:37:36 +0900</pubDate>
        <guid>https://myuon.github.io/posts/golang-and-rust/</guid>
        <description>コンテキスト 私もGoとRustの比較記事書いてバズるやつやりたい
&amp;mdash; みょん (@myuon_myon) February 27, 2020  仕事でGoとRustを書いています。いずれもWebのサーバーサイドです。パフォーマンスとかほとほどって感じなので極限までチューニングしたりしません。という前提で読んでください。
Rust/Goはいずれも習得してから2年くらい書いています。書いてる量も多分そんなに変わりません。
Go なんと言っても習得難度が低いので人を選ばず書けるようになります。現状だと仕事で書くなら一番無難な選択肢だなと思っています。一方言語もエコシステムも何もかもかなりクセが強いので、Go Wayにちゃんと従うことが大事だなと思ったりします。
 ジェネリクスがないことは高速なコンパイルなど利点もありますがmap,filter等を型ごとにfor文書きまくることになるのでとても手が疲れます。スライスに値が入ってるかどうかをチェックする標準関数用意しといてくれ〜〜〜っていつも思う。 基本的に公式がユーザーに不便を強いる感じになっており、あまり便利さを追求しないほうが良いです。あとリポジトリのissueでGoodが100以上ついてるfeature requestを「対応しません」って言って問答無用で閉じたりするの結構趣がありますね。Goに入ってはGoに従えない人には向いてないです。 syntaxの一貫性があまりなく、結構Adhocな構文要素が多いです。特にゼロ値周りはヤバく、適当に書くとかなり気づきにくいバグを埋め込むおそれがあるのでチームで書くときはコード規約は必須です。公式がコード規約を出しているので、こういうのにとりあえず従っておくのが無難かもしれない。(なお結構うげーとなるような規約があるので私は全部は従いたくないです。) コンパイルが速くstatic buildが超カンタンなのはサイコーって感じですね(この辺はruntimeの出来がめちゃくちゃ良いのでそのへんのおかげ)。Dockerとの相性も良いのであんまり何も考えなくてもものが動いてサイコーです。 GoLandやVSCode pluginの出来が普通に良いのでDXはとても良いです。それはそうとVSCodeはなぜかcompletionの反応速度が異常に悪いので最近はもっぱらGoLandになりました。文明的だなあという気持ちになれて良いです。 標準ライブラリがやたら豪華なので結構何でも提供してくれています。大変便利です。言語人口が多いこともあってライブラリも(少なくとも数は)豊富です。 マクロとかそういうのもないので筋力が全てです。コーディングには筋肉をつけましょう。 仕事ではechoとgormを使っています。  Rust 使いこなせるようになればめちゃ便利な言語です。言語機能が強力なのとエコシステムが整っており、個人的な感覚ではライブラリも強力なものが多いので頼もしいです。習得難度が高いことと未だに言語自体が枯れていないため、界隈の趨勢が変わるとそれに振り回されそうな不安もあります。
 とにかくコンパイルが遅いです。キャッシュしないとCIのビルド時間が(releaseビルドなのもあり)30分とかになります。誰か助けてほしい。 LSPが微妙にやる気がないです。なんかあんまり補完してくれないときとかがある。もうちょっとやる気を出してほしい。(VSCode) Goと違ってジェネリクスにADTにマクロもあって文明的です。工夫すればコードの治安を良い感じに保つことが出来ます。 最近はasync runtime周りでの動きが活発です。特にasync/awaitが最近になって安定化されたこともあり、「future0.1にのみ対応した非同期APIのないライブラリ」「future0.3に対応したasync/awaitで書けるライブラリ」が入り乱れています。さらにasync runtimeは現状はtokioが一番強いですが、最近になってasync-stdというのが登場し、これが覇権を握ることになるとtokioに依存するライブラリが一斉に死滅する可能性があります。各種ライブラリはasync-stdが台頭するとtokioと非互換なため動かなくなるという状況に危機感を感じているようですが、現状で非同期に対応しているライブラリはほぼruntimeと密結合しているため、すぐには解決されないと思われます。今年や来年にはasync runtime大戦争が起きる可能性があり、仕事でtokio依存ライブラリを使っている身としてはかなり戦々恐々としています。ちなみに最近一瞬消滅しかかったことで話題になったWebフレームワークのactix-webは、独自のthreadpoolを持っているためtokioともasync-stdとも互換性がないです。(async/awaitがもう少し浸透したらこのまま消える可能性もあるのではと個人的には思っている) 学習コストはかなり高いと思います。Goに比べて言語機能がとにかく多いことと、↑のようにライブラリや言語自体がまだ発展途上であること、Goと違ってあまりeasy方面に振ってないライブラリが多いところなどにその理由があると感じています。ちなみにパフォーマンスを追求するわけでも低レイヤーであれこれするわけでもなく普通にアプリケーションを書くだけなら、巷で言われてるほど所有権とかライフタイムとかで詰まることはないと思います。 仕事ではhyperとdieselを使っています。(diesel辞めたいって毎秒言っている)  終わりに Rustがあまり憎しみの対象にならないのは単に仕事で書いてる人の数が少ないからだよ
&amp;mdash; みょん (@myuon_myon) February 15, 2020  </description>
      </item>
    
      <item>
        <title>RustとNode.js間通信にgRPCを使う</title>
        <link>https://myuon.github.io/posts/grpc-rust/</link>
        <pubDate>Sun, 28 Oct 2018 16:03:12 +0900</pubDate>
        <guid>https://myuon.github.io/posts/grpc-rust/</guid>
        <description>gRPCしたくなった。具体的にはRustで作ってるデスクトップアプリケーションで、GUIをElectronで書きたいのでNode.jsと通信が発生するのでそれに使えないかなと思って調査した。
gRPC(protocol buffers)とは gRPCはgoogleが作ったRPC(remote procedure call)のフレームワークで、簡単に言うとサーバー/クライアント間の通信が言語を問わずできるよ！みたいなやつ。 RPC自体は見た目は普通の関数呼び出しみたいな感じで書けて、裏ではHTTP/2の通信に乗ってやりとりが行われるようになっている。実際にはRPCを定義してからそれを呼び出すためにはサーバーやクライアントで言語ごとにインターフェイスの定義とかをしなければいけないが、それを自動で生成してくれるのがgRPCコンパイラという感じ。
gRPCを使うには、protocol buffersというプロトコル定義言語(?)を.protoファイルに書いてgRPCコンパイラで言語ごとにコンパイルを行う。2018/10/28現在では公式にサポートされてる言語がC++, Java, Python, Go, Rusy, C#, Node.js, Android Java, Obj-C, PHP, Dartなどなど多岐にわたる。Rustは非公式だけどプラグインがあるので使える。
gRPC/protocol buffersの個人的なポイントをまとめてみる。
長所:
 サポートされてる言語が多い ツール自体はしっかりしてるのであまりその辺で変にハマることはなさそう streaming通信なんかもサポートされてる protocol buffers自体が後方互換性を命を懸けて守るという強い意志のもとに設計されてる まぁこれはそのせいで面倒なこともあるので短所でもあるけど、多くの人にとっては長所になりうるかと思う protoファイルからドキュメント生成するやつもある(proto-gen-doc) protocol buffers自体は普通にプログラミング言語による型定義みたいな感じで普通に書きやすい(少なくともswaggerみたいな地獄のyaml UXとかに比べたら断然楽)  短所:
 公式ドキュメントが死ぬほど分かりにくい(Googleだからしょうがない説もあるが) ツールのインストール方法などが死ぬほど分かりにくい 現状ブラウザによるネイティブサポートがない(grpc-gatewayを使うといいらしいよ) [追記] (grpc-webというので対応されたらしい) [/追記] 生成するコードにユーザー側の自由度がほぼないし自力でプラグインを書くのは多分大変(のでユースケースによっては全く使えないと思う)  最近はマイクロサービス間通信とかで採用されてる事例が多いみたい。実際にブラウザとの通信で使ってる人はそこまで多くない印象だった。
RustでgRPC Rustでサーバー側の処理を書く。
まず、上にも書いたようにprotoをRustコードに変換するgRPCコンパイラのRustプラグインが必要になる。これにはprotobuf-codegenとgrpcio-compilerを使うといいよってあった。
# インストール $ cargo install protobuf-codegen grpcio-compiler # コンパイル $ protoc --rust_out=. --grpc_out=. --plugin=protoc-gen-grpc=`which grpc_rust_plugin` example.proto これによって生成されたRustモジュールを読み込んで使うことになるけど、それにはgrpc-rsを使った(grpc-rustというのもあるけどこっちは触ってない)。
サーバー側のプログラムはこんな感じで書くと良い。
コンパイルすると、protocol buffersのmessageが定義されたexample.rsと、RPC関連が定義されたexample_grpc.rsが生成される。
Node.jsでgRPC Node.</description>
      </item>
    
      <item>
        <title>動画編集ソフトを作り始めた</title>
        <link>https://myuon.github.io/posts/madder-start-to-create/</link>
        <pubDate>Sun, 04 Mar 2018 19:21:20 +0900</pubDate>
        <guid>https://myuon.github.io/posts/madder-start-to-create/</guid>
        <description>Rustを使い始めて1ヶ月だぜ体験記みたいなのを書こうとしたけどせっかくなので今やってることも全部まとめて1本の記事にすることにした。  最近日本語をかくのがめんどくさい以外の発言をしていない気がする。  1ヶ月ほど前に動画編集ソフトを作りたくなって、言語はRust メディアフレームワークにGstreamer GUIにGTK+を使うのだけどこの3つをどれも触ったことがない状態で作り始めるという完全に勢いだけのアレというのが前置き。 Rust   前回の記事でも色々言ってたけどその後分かったことなんかを記しておく(本当はWHAT I WISH I KNEW WHEN LEARNING RUSTみたいにしてまとめると良いのだろうなぁ)    とりあえずメモリモデルとしてはスタックとヒープがあるということだけ分かっておけば大丈夫そう    structのフィールドに参照をもたせるとlifetime parameterにコードがまみれるのでやめたほうが良さそう    Rc&amp;lt;RefCell&amp;lt;T&amp;gt;&amp;gt; が便利(これは主にGTKを使う時に必要になったというのもある)    Rc&amp;lt;RefCell&amp;lt;T&amp;gt;&amp;gt; は確かに便利だけど hoge.borrow_mut().call(hoge.borrow()) みたいなことをするとBorrowMutError: already borrowedで実行時エラーになって死ぬので気をつけよう    参照が欲しいときはBorrow, BorrowMut, AsRef, AsMutトレイトの実装があるかを見よう    Derefトレイトは神    Fn, FnMut, FnOnceの意味がようやく分かってきた FnOnce系はちょっと気をつけたほうがいい(Option::unwrapがselfを消費するのとか)    trait, implは飽くまでインターフェイスの提供だけなのでデータの扱いはstructで行う    OOPっぽくコード書きたいときはtrait objectと動的ディスパッチの仕組みを上手く使う(果たしてこれが正しいアレなのかはよく分からん)    マクロは便利    別言語でtrailing commaで怒られると厳しい気持ちになる    if letが意外と便利    言語拡張が結構カジュアルに欲しくなるのでこのままだとnightlyしか使わなくなりそう    文字列リテラルが常に&amp;amp;strなのは意外とパターンマッチの時にめんどくさい マジでViewPatterns拡張が欲しい マジで    大抵の他の言語でもそうなんだけどasって書くのめんどくさい    あと as (i32,i32) って書けないの割と不便    前は「ブロックをclosureや関数として切り出してくると怒られるの理不尽💢」みたいなことを思っていたのだけれど、closureや関数は複数回呼ばれる可能性がある上に呼ばれるタイミングが不明なので所有権をちゃんと考えないといけないということが分かりスッキリした    最近Derefは神だなと思うことがあり、今まで(なんでこれ型が合うんだろう〜)って思ってたところは大体Derefのおかげであることが分かったりした。  例えば hoge: Rc&amp;lt;RefCell&amp;lt;T&amp;gt;&amp;gt; に対して hoge.</description>
      </item>
    
      <item>
        <title>Rustに入門した</title>
        <link>https://myuon.github.io/posts/rust-started/</link>
        <pubDate>Fri, 09 Feb 2018 22:21:42 +0900</pubDate>
        <guid>https://myuon.github.io/posts/rust-started/</guid>
        <description>  Rustに入門して2週間くらい経ったぜ  TL;DR Rustは普通に便利ないい言語 入門した   入門にあたってはプログラミング言語Rustを読んだ。これの翻訳版ぽい。  読んでRustに対して思ったこと:    読んだやつは古いドキュメントの翻訳版だったようで一部記述が古いっぽかった    構文はシンプルだけど必要なものは揃ってる感 ML風でADTもパターンマッチもあるしtraitもあって言うことナシでしょ    所有権とか借用とかそういう聞いたことあるワードは参照という概念に対するアレっぽい    ｽｨｰ言語を気軽に(unsafe)呼べるのはFFIするとき良さそう 強そう    マクロ割と便利そうな雰囲気ある    RcとかArcとかCellとかいう便利なものがあるらしい あとBoxはいつ使うんじゃ    参照わかったようでわからない とりあえずスタックとヒープの違いは覚えたぞ    入門書なのに普通にするする読めてしまったし特に難しいことがなかった、もしかしてRustは簡単なのでは？？？    参照とかいう概念がある言語を長らくやっていなかった(Pythonは基本参照だった気がするけど意識する場面ないしHaskellの参照もあんまり使わないしなぁ)ので 「あー参照だとこういうことも考えないといけないのかぁ」って思ったりした  参照、人類には早すぎるのでは？？？って感じ ちょっと書いたりした   ちょっと書いたりした(してる)  どうせなのでなんか作ってみるかぁと思ってgstreamerとGtkで動画をごにょごにょするアプリケーションを作って遊んでる。 なんで入門していきなりそんな重いもの作ってんだよという感じなのだけどRustの強みはやっぱりCにFFIしやすいことな気がしていて逆にHaskellでは現状まともにビルドできてまともに使えるGUIライブラリがないので、そういう意味で(Rustの強みを活かせるという意味で)GUIアプリケーションぽいものに着手した。  まぁまだそんな書いてないしな〜(と思ったがすでに700行近い。Haskellなら500行超えるだけで相当だけど中括弧でブロック表す上に手続きがデフォルトの言語ってめっちゃ行数かさむよね。)  しばらく書いた感想:    エラーメッセージがカラフルや…なんだこれ…(GHCも最近カラフルになったけど未だに慣れない感ある)    ｽｨｰ言語と違って コンパイラが信用できるーーーﾔｯﾀーーー(踊りだす)    エコシステムが強すぎてビビる(いやHaskellがダメなだけか…？)    Rc Cell RefCellあたりがあまりに便利    所有権意識する場面あんまない    *(スター)はRustが勝手に補ってくれるって書いてあったので一切書いてないんだけどいいのかこれで 結局*が何者なのか未だによくわからない    そもそも自分はHaskell出身だからmutとか使う場面あんまないな そりゃ苦労しないはずですわ    FFIするのはほんとにシームレスで強さしかない    参照、人類には早すぎるのでは？？？？？？    ポインタだとコンパイル時にアドレス分の長さしか食わないがデータによってはコンパイル時にその長さが分からないみたいなエラーを見て、長さがわからないとallocateができない！そういうのもあるのか！になった    lifetimeの存在により自然にステートの管理の意識がブロックに宿るようになるの結構すごい 人類はステート管理に対する新たなやり方を手に入れたのでは？ってちょっと思った    もしかしてRustは簡単なのでは？？？？？？   所感   巷では難しい言語だみたいに言われることがあるような気がするけどめちゃくちゃ簡単やんけ！と思った (自分は特殊な人間である自覚はあるので大方の人には難しいのかもしれない)  というか、たしかに所有権を完全にコントロールして正しい設計を導き出すのは難しいんだけど、それは参照とかいう概念が全て悪いのであってRustはむしろそれを管理するための適切でhuman-friendlyな方法を提供してくれてるしすごいいい言語じゃん！と思ったりした  あとコンパイラを全面的に信用できるのも大きい。雑なことしてもどっかおかしかったらコンパイラが教えてくれるしな！という感じでガシガシ書いていける。  「higher kind typeがない」って言うのは聞いてて自分は今の所なくていいんじゃない？派なんだけどやっぱ場合によっては不便なんだろうか。 HKTって実装のコストと学習コストの肥大化の割に恩恵が大したことないというイメージだし、どうせHKT入れても次はアレをいれてくれコレもいるだろみたいになるのは必至なので(型システムとはそういう宿命なのだ)今の小さくて十分パワフルなRustでいいんじゃないでしょうか。  それでも自分はHaskellの方が圧倒的に慣れてるのもあるので、敢えてRust使うならやっぱGUI方面かな〜(RustはFFI強いし楽だし一方Haskellは全然ライブラリメンテされてないし)と思ってる。 まーでもmakeLensesしないとまともなレコードも使えない某言語を頑張って使い続ける理由はあるのだろうかというアレも。 やっぱRustに比べるとHaskellは難しい言語だなぁと思いますね。  以上 </description>
      </item>
    
  </channel>
</rss>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Rust on The curse of λ</title>
    <link>https://myuon.github.io/tags/rust/</link>
    <description>Recent content in Rust on The curse of λ</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-jp</language>
    <lastBuildDate>Sun, 28 Oct 2018 16:03:12 +0900</lastBuildDate>
    
      <atom:link href="https://myuon.github.io/tags/rust/index.xml" rel="self" type="application/rss+xml" />
    
    
      <item>
        <title>RustとNode.js間通信にgRPCを使う</title>
        <link>https://myuon.github.io/posts/grpc-rust/</link>
        <pubDate>Sun, 28 Oct 2018 16:03:12 +0900</pubDate>
        <guid>https://myuon.github.io/posts/grpc-rust/</guid>
        <description>gRPCしたくなった。具体的にはRustで作ってるデスクトップアプリケーションで、GUIをElectronで書きたいのでNode.jsと通信が発生するのでそれに使えないかなと思って調査した。
gRPC(protocol buffers)とは gRPCはgoogleが作ったRPC(remote procedure call)のフレームワークで、簡単に言うとサーバー/クライアント間の通信が言語を問わずできるよ！みたいなやつ。 RPC自体は見た目は普通の関数呼び出しみたいな感じで書けて、裏ではHTTP/2の通信に乗ってやりとりが行われるようになっている。実際にはRPCを定義してからそれを呼び出すためにはサーバーやクライアントで言語ごとにインターフェイスの定義とかをしなければいけないが、それを自動で生成してくれるのがgRPCコンパイラという感じ。
gRPCを使うには、protocol buffersというプロトコル定義言語(?)を.protoファイルに書いてgRPCコンパイラで言語ごとにコンパイルを行う。2018/10/28現在では公式にサポートされてる言語がC++, Java, Python, Go, Rusy, C#, Node.js, Android Java, Obj-C, PHP, Dartなどなど多岐にわたる。Rustは非公式だけどプラグインがあるので使える。
gRPC/protocol buffersの個人的なポイントをまとめてみる。
長所:
 サポートされてる言語が多い ツール自体はしっかりしてるのであまりその辺で変にハマることはなさそう streaming通信なんかもサポートされてる protocol buffers自体が後方互換性を命を懸けて守るという強い意志のもとに設計されてる まぁこれはそのせいで面倒なこともあるので短所でもあるけど、多くの人にとっては長所になりうるかと思う protoファイルからドキュメント生成するやつもある(proto-gen-doc) protocol buffers自体は普通にプログラミング言語による型定義みたいな感じで普通に書きやすい(少なくともswaggerみたいな地獄のyaml UXとかに比べたら断然楽)  短所:
 公式ドキュメントが死ぬほど分かりにくい(Googleだからしょうがない説もあるが) ツールのインストール方法などが死ぬほど分かりにくい 現状ブラウザによるネイティブサポートがない(grpc-gatewayを使うといいらしいよ) [追記] (grpc-webというので対応されたらしい) [/追記] 生成するコードにユーザー側の自由度がほぼないし自力でプラグインを書くのは多分大変(のでユースケースによっては全く使えないと思う)  最近はマイクロサービス間通信とかで採用されてる事例が多いみたい。実際にブラウザとの通信で使ってる人はそこまで多くない印象だった。
RustでgRPC Rustでサーバー側の処理を書く。
まず、上にも書いたようにprotoをRustコードに変換するgRPCコンパイラのRustプラグインが必要になる。これにはprotobuf-codegenとgrpcio-compilerを使うといいよってあった。
# インストール $ cargo install protobuf-codegen grpcio-compiler # コンパイル $ protoc --rust_out=. --grpc_out=. --plugin=protoc-gen-grpc=`which grpc_rust_plugin` example.proto これによって生成されたRustモジュールを読み込んで使うことになるけど、それにはgrpc-rsを使った(grpc-rustというのもあるけどこっちは触ってない)。
サーバー側のプログラムはこんな感じで書くと良い。
コンパイルすると、protocol buffersのmessageが定義されたexample.rsと、RPC関連が定義されたexample_grpc.rsが生成される。</description>
      </item>
    
      <item>
        <title>動画編集ソフトを作り始めた</title>
        <link>https://myuon.github.io/posts/madder-start-to-create/</link>
        <pubDate>Sun, 04 Mar 2018 19:21:20 +0900</pubDate>
        <guid>https://myuon.github.io/posts/madder-start-to-create/</guid>
        <description>Rustを使い始めて1ヶ月だぜ体験記みたいなのを書こうとしたけどせっかくなので今やってることも全部まとめて1本の記事にすることにした。
最近日本語をかくのがめんどくさい以外の発言をしていない気がする。
1ヶ月ほど前に動画編集ソフトを作りたくなって、言語はRust メディアフレームワークにGstreamer GUIにGTK+を使うのだけどこの3つをどれも触ったことがない状態で作り始めるという完全に勢いだけのアレというのが前置き。
Rust 前回の記事でも色々言ってたけどその後分かったことなんかを記しておく(本当はWHAT I WISH I KNEW WHEN LEARNING RUSTみたいにしてまとめると良いのだろうなぁ)
 とりあえずメモリモデルとしてはスタックとヒープがあるということだけ分かっておけば大丈夫そう structのフィールドに参照をもたせるとlifetime parameterにコードがまみれるのでやめたほうが良さそう Rc&amp;lt;RefCell&amp;lt;T&amp;gt;&amp;gt; が便利(これは主にGTKを使う時に必要になったというのもある) Rc&amp;lt;RefCell&amp;lt;T&amp;gt;&amp;gt; は確かに便利だけど hoge.borrow_mut().call(hoge.borrow()) みたいなことをするとBorrowMutError: already borrowedで実行時エラーになって死ぬので気をつけよう 参照が欲しいときはBorrow, BorrowMut, AsRef, AsMutトレイトの実装があるかを見よう Derefトレイトは神 Fn, FnMut, FnOnceの意味がようやく分かってきた FnOnce系はちょっと気をつけたほうがいい(Option::unwrapがselfを消費するのとか) trait, implは飽くまでインターフェイスの提供だけなのでデータの扱いはstructで行う OOPっぽくコード書きたいときはtrait objectと動的ディスパッチの仕組みを上手く使う(果たしてこれが正しいアレなのかはよく分からん) マクロは便利 別言語でtrailing commaで怒られると厳しい気持ちになる if letが意外と便利 言語拡張が結構カジュアルに欲しくなるのでこのままだとnightlyしか使わなくなりそう 文字列リテラルが常に&amp;strなのは意外とパターンマッチの時にめんどくさい マジでViewPatterns拡張が欲しい マジで 大抵の他の言語でもそうなんだけどasって書くのめんどくさい あと as (i32,i32) って書けないの割と不便 前は「ブロックをclosureや関数として切り出してくると怒られるの理不尽💢」みたいなことを思っていたのだけれど、closureや関数は複数回呼ばれる可能性がある上に呼ばれるタイミングが不明なので所有権をちゃんと考えないといけないということが分かりスッキリした  最近Derefは神だなと思うことがあり、今まで(なんでこれ型が合うんだろう〜)って思ってたところは大体Derefのおかげであることが分かったりした。
例えば hoge: Rc&amp;lt;RefCell&amp;lt;T&amp;gt;&amp;gt; に対して hoge.borrow(): &amp;amp;T で一発でTへの参照が得られるんだけど、これは (*hoge).borrow() が勝手に補われており、更にRcのDerefの実装は中身への参照を取り出すようになってるからいい感じに出来るというのがある。
他にも、Rustは基本的にexplicitな言語であるけれどDerefだけは暗黙に色々やってくれるのでこいつのおかげで知らぬ間に記述が楽になってるところがあったりした。便利っぽい。
思ったよりいいたいことがなかった。最近Rustの勉強と言うよりGTKとかの勉強に時間もコストも取られてる感あるからかなぁ。
GTK+ gtk-rsというプロジェクトがありGTK関係のライブラリを色々提供してくれているので使ってる。たまに対応してないAPIがあるのとドキュメントにfeatureの指定が書いてないのでたまにハマる。
 gtk: gtkのガワ widgetとかを提供する gdk: 中身？ 内部実装のあれこれを提供する cairo: 2Dグラフィックスライブラリ pango: フォントレンダリングライブラリ pixbuf: cairo等で扱えるpixel buffer githubのイシューにもあるんだけど登録するcallbackがほぼ&#39;staticを要求するのでコード内の状態をcallback越しに持っていけない それを解決するために Rc&amp;lt;RefCell&amp;lt;S&amp;gt;&amp;gt; が必要になる widgetが色々あるようで実はそんなにない ちょっと凝ったことするなら自作するしかない widgetは内部状態を持っていてそれ自体がMVCみたいな感じになっているのでデータの持ち方を中央集権的にしようとすると結構めんどくさい Elmの人も言っていたが何でもコンポーネントは(ライブラリは作りやすいけど)あんまりいい設計ではない気がする ViewはModelからの単なる関数にしたほうが素直 ドキュメントが豊富なので頑張って読めば意外となんとかなる(ただし本家以外は基本アテにならない)  Gstreamer gstreamer-rsというライブラリがある。これもたまに対応してないAPIが(ry</description>
      </item>
    
      <item>
        <title>Rustに入門した</title>
        <link>https://myuon.github.io/posts/rust-started/</link>
        <pubDate>Fri, 09 Feb 2018 22:21:42 +0900</pubDate>
        <guid>https://myuon.github.io/posts/rust-started/</guid>
        <description>Rustに入門して2週間くらい経ったぜ
TL;DR Rustは普通に便利ないい言語
入門した 入門にあたってはプログラミング言語Rustを読んだ。これの翻訳版ぽい。
読んでRustに対して思ったこと:
 読んだやつは古いドキュメントの翻訳版だったようで一部記述が古いっぽかった 構文はシンプルだけど必要なものは揃ってる感 ML風でADTもパターンマッチもあるしtraitもあって言うことナシでしょ 所有権とか借用とかそういう聞いたことあるワードは参照という概念に対するアレっぽい ｽｨｰ言語を気軽に(unsafe)呼べるのはFFIするとき良さそう 強そう マクロ割と便利そうな雰囲気ある RcとかArcとかCellとかいう便利なものがあるらしい あとBoxはいつ使うんじゃ 参照わかったようでわからない とりあえずスタックとヒープの違いは覚えたぞ 入門書なのに普通にするする読めてしまったし特に難しいことがなかった、もしかしてRustは簡単なのでは？？？  参照とかいう概念がある言語を長らくやっていなかった(Pythonは基本参照だった気がするけど意識する場面ないしHaskellの参照もあんまり使わないしなぁ)ので 「あー参照だとこういうことも考えないといけないのかぁ」って思ったりした
参照、人類には早すぎるのでは？？？って感じ
ちょっと書いたりした ちょっと書いたりした(してる)
どうせなのでなんか作ってみるかぁと思ってgstreamerとGtkで動画をごにょごにょするアプリケーションを作って遊んでる。 なんで入門していきなりそんな重いもの作ってんだよという感じなのだけどRustの強みはやっぱりCにFFIしやすいことな気がしていて逆にHaskellでは現状まともにビルドできてまともに使えるGUIライブラリがないので、そういう意味で(Rustの強みを活かせるという意味で)GUIアプリケーションぽいものに着手した。
まぁまだそんな書いてないしな〜(と思ったがすでに700行近い。Haskellなら500行超えるだけで相当だけど中括弧でブロック表す上に手続きがデフォルトの言語ってめっちゃ行数かさむよね。)
しばらく書いた感想:
 エラーメッセージがカラフルや…なんだこれ…(GHCも最近カラフルになったけど未だに慣れない感ある) ｽｨｰ言語と違って コンパイラが信用できるーーーﾔｯﾀーーー(踊りだす) エコシステムが強すぎてビビる(いやHaskellがダメなだけか…？) Rc Cell RefCellあたりがあまりに便利 所有権意識する場面あんまない *(スター)はRustが勝手に補ってくれるって書いてあったので一切書いてないんだけどいいのかこれで 結局*が何者なのか未だによくわからない そもそも自分はHaskell出身だからmutとか使う場面あんまないな そりゃ苦労しないはずですわ FFIするのはほんとにシームレスで強さしかない 参照、人類には早すぎるのでは？？？？？？ ポインタだとコンパイル時にアドレス分の長さしか食わないがデータによってはコンパイル時にその長さが分からないみたいなエラーを見て、長さがわからないとallocateができない！そういうのもあるのか！になった lifetimeの存在により自然にステートの管理の意識がブロックに宿るようになるの結構すごい 人類はステート管理に対する新たなやり方を手に入れたのでは？ってちょっと思った もしかしてRustは簡単なのでは？？？？？？  所感 巷では難しい言語だみたいに言われることがあるような気がするけどめちゃくちゃ簡単やんけ！と思った (自分は特殊な人間である自覚はあるので大方の人には難しいのかもしれない)
というか、たしかに所有権を完全にコントロールして正しい設計を導き出すのは難しいんだけど、それは参照とかいう概念が全て悪いのであってRustはむしろそれを管理するための適切でhuman-friendlyな方法を提供してくれてるしすごいいい言語じゃん！と思ったりした
あとコンパイラを全面的に信用できるのも大きい。雑なことしてもどっかおかしかったらコンパイラが教えてくれるしな！という感じでガシガシ書いていける。
「higher kind typeがない」って言うのは聞いてて自分は今の所なくていいんじゃない？派なんだけどやっぱ場合によっては不便なんだろうか。 HKTって実装のコストと学習コストの肥大化の割に恩恵が大したことないというイメージだし、どうせHKT入れても次はアレをいれてくれコレもいるだろみたいになるのは必至なので(型システムとはそういう宿命なのだ)今の小さくて十分パワフルなRustでいいんじゃないでしょうか。
それでも自分はHaskellの方が圧倒的に慣れてるのもあるので、敢えてRust使うならやっぱGUI方面かな〜(RustはFFI強いし楽だし一方Haskellは全然ライブラリメンテされてないし)と思ってる。 まーでもmakeLensesしないとまともなレコードも使えない某言語を頑張って使い続ける理由はあるのだろうかというアレも。 やっぱRustに比べるとHaskellは難しい言語だなぁと思いますね。
以上</description>
      </item>
    
  </channel>
</rss>

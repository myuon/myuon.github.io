<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>静的解析 on The curse of λ</title>
    <link>https://myuon.github.io/tags/%E9%9D%99%E7%9A%84%E8%A7%A3%E6%9E%90/</link>
    <description>Recent content in 静的解析 on The curse of λ</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-jp</language>
    <lastBuildDate>Wed, 11 Jul 2018 05:49:39 -0700</lastBuildDate>
    
      <atom:link href="https://myuon.github.io/tags/%E9%9D%99%E7%9A%84%E8%A7%A3%E6%9E%90/index.xml" rel="self" type="application/rss+xml" />
    
    
      <item>
        <title>静的解析の限界、現実世界との境界</title>
        <link>https://myuon.github.io/posts/how-far-can-static-analysis-go/</link>
        <pubDate>Wed, 11 Jul 2018 05:49:39 -0700</pubDate>
        <guid>https://myuon.github.io/posts/how-far-can-static-analysis-go/</guid>
        <description>はじめに 2018年に静的解析をとにかく強力につけまくるのは多分あんまりコストに見合わないのでよくない
じゃあ静的解析を窓から投げ捨ててよいかというとそれはただの愚行
(以下、静的解析を普通に使えてる人には自明なことしか言いません)
依存型のつらみ 私が最初に静的解析の限界を感じたのは多分依存型で遊んでいたとき
依存型の力はすごくて、まぁそれもそのはず命題論理から述語論理に進んで元への言及ができるので見かけ上表現力はとんでもなく上がるわけです。例えば「ある方程式を満たす解のみを受け取って何かする」みたいな関数が型として表現できるようになる。
一見すると最強に見えるんだけどこれは実質定理証明をすることなので、制限の強い型をつければつけるほど実装で苦しむ羽目になるということを割とすぐ痛感することになった。
例えば head : Vect (Suc n) a -&amp;gt; a で長さ1以上のvectorの先頭を安全に取り出す関数を表現できる。 これはコンストラクタを見るだけなので実装も簡単ですね。 それでは今度は quick_sort : (xs: Vect n a) -&amp;gt; \exists (ys: Vect n a). Increasing ys /\ Isomorphic xs ys (読み方としては、長さnのvectorを受け取って、「長さnのvectorであって、昇順に並んでおり、適当に順番を入れ替えるとxsに一致するもの」を返す関数と読みます)とかどうかというとまぁこれを見てすぐ実装が思いつく人はいないでしょう。
やってみると分かるがこれに実装を与えるためには相当な定理証明力を要求される。もはや関数型プログラミングですらない、単なる定理証明である。
とか言う話は↓にもよくまとまっているのでよければ読んで
 問題を解決するつもりでキッチリ型を付けた先にある高い壁 - ぼくのぬまち 出張版 実世界を扱う依存型プログラミングのたぶん基本～外界から安全な世界までの道 - ぼくのぬまち 出張版  Welcome to 現実 上の記事にも書いてあるんだけど、実は依存型のつらみはこれだけではない(そして今回の記事はむしろこっちの話を書きたい)
例えば先程のquick_sort関数をめでたく実装できたとしよう、すると我々はwell-sortednessが証明されたquick_sortを手にしたことになる。素晴らしい！ではこのquick_sortを使ってみよう！
普通のアプリケーションであればquick_sortにはリストを食わせた後そのまま普通に使ってデータとしては捨てられてしまうかもしれない。quick_sortから返却されたリストが 昇順に並んでいる ことが保証されていなければならないアルゴリズムを書く人がどれだけいるのだろうか？ もちろんソートされていなければ後々まずいことになるということは往々にしてあるが、それが至るところに出現するということはあまりなさそうだ。数百行のプログラム中で1-2ヶ所、たかがその程度だろう。 quick_sortを実装するために支払ったコストは本当にここの嬉しさを上回るのだろうか？
あるいは、もっとひどければ全く利用されないこともある。ソートされたデータを一度DBやファイルに書き出してしまえば、型の保証はなくなってしまう。ファイルに書き込まれる前にソートされたことが型で保証されていたデータは、ファイルから読み出したときにはすでにその保証を失っている。
実際にはシステムレベルでの保証というのがある。ファイルに読み書きされると当然型による保証は失われてしまうが、「そのファイルがこのプログラム以外で読み書きされないことを仮定してよいのなら」ソートされたデータを書き込んだファイルは再び読み込むとソートされているとしてよいはずである。 というわけでプログラムの型レベルでは保証できなくとも、 システム全体がまともに動いているなら ちゃんと制約を満たしてくれているはず、というのがある。
システムレベルでの「保証」とは人間の頭の中にしかなく、通常いくつかの仮定が必要であるので型システムではうまく取り扱うことができず、例えば unsafeCoerce : a -&amp;gt; b のような関数の出番ということになる。</description>
      </item>
    
  </channel>
</rss>

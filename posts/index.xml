<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on The curse of λ</title>
    <link>https://myuon.github.io/posts/</link>
    <description>Recent content in Posts on The curse of λ</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-jp</language>
    <lastBuildDate>Sun, 04 Nov 2018 12:32:56 +0900</lastBuildDate>
    
      <atom:link href="https://myuon.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    
    
      <item>
        <title>Elm: Concurrent FRP for Functional GUIsを読んで</title>
        <link>https://myuon.github.io/posts/elm-functional-gui/</link>
        <pubDate>Sun, 04 Nov 2018 12:32:56 +0900</pubDate>
        <guid>https://myuon.github.io/posts/elm-functional-gui/</guid>
        <description>これ
https://elm-lang.org/assets/papers/concurrent-frp.pdf
はじめに 某所でFRPをeffect systemとみなせないか、という大変示唆的な質問をいただいて、気になったのでFRPについて調べてた流れで教えてもらったElmの作者が書いた論文。 自分はFRPについては「なんかEventとBehaviorがあってArrowになったりMonadになったりするやつ」くらいの感覚しかなかったので論文読んでみることにした。
ところでmarkdownで数式や図を記述するのは大変つらいので記事は適当に日本語で書きます。詳しく知りたい人は論文の方を読んでください。
あと、ElmはFRP捨てたって言ってた気がするので多分今のElmはもう論文にあるような仕組みで動いてないような気がしないでもない。
2章 背景  FRPにはClassical, Real-time (とEvent-driven), Arrowizedの3種類ある Classical:  Behavior a = Time -&amp;gt; a: これが時間の経過とともに変わる値を表現する Event a = [(Time, a)]: これがBehaviorのスナップショットを取ったもの 基本はBehaviorをベースに計算を行うけど、実際のプログラムでは無限に細かい時間で計算はできないので30fpsとか決まったタイミングで再計算するかどうかを考えることになる。そういう離散化のためにEventがあるよみたいな感じ  Real-time:  Event a = Behavior (Maybe a) EventもBehaviorで書いちゃえばいいんちゃうん Event, Behaviorをまとめて Signal a = Time -&amp;gt; a と呼ぶことに 論文で説明されてるElm Coreもこれにinspireされてるっぽい  Arrowized:  SF a b = Signal a -&amp;gt; Signal b signal functionというものをベースにしてこれをArrowにする 論文読んだ限りだと理論が難しくなりそうなのでFRPにおける特にArrowの優位性はよくわからなかった 書きやすいってくらいなのか  Message-Passing Concurrency  Concurrent MLの説明 実装はこれで書いたり書かなかったりする(あとの章でtranslationが与えられる)  既存のFRP GUI frameworks  メモリリークする(Haskellなので)(って何度も書いてあってウケるって思った)   3章 Core Language  Dicreteなsignalを扱う 文法: e ::= () | n \in Z | \x.</description>
      </item>
    
      <item>
        <title>RustとNode.js間通信にgRPCを使う</title>
        <link>https://myuon.github.io/posts/grpc-rust/</link>
        <pubDate>Sun, 28 Oct 2018 16:03:12 +0900</pubDate>
        <guid>https://myuon.github.io/posts/grpc-rust/</guid>
        <description>gRPCしたくなった。具体的にはRustで作ってるデスクトップアプリケーションで、GUIをElectronで書きたいのでNode.jsと通信が発生するのでそれに使えないかなと思って調査した。
gRPC(protocol buffers)とは gRPCはgoogleが作ったRPC(remote procedure call)のフレームワークで、簡単に言うとサーバー/クライアント間の通信が言語を問わずできるよ！みたいなやつ。 RPC自体は見た目は普通の関数呼び出しみたいな感じで書けて、裏ではHTTP/2の通信に乗ってやりとりが行われるようになっている。実際にはRPCを定義してからそれを呼び出すためにはサーバーやクライアントで言語ごとにインターフェイスの定義とかをしなければいけないが、それを自動で生成してくれるのがgRPCコンパイラという感じ。
gRPCを使うには、protocol buffersというプロトコル定義言語(?)を.protoファイルに書いてgRPCコンパイラで言語ごとにコンパイルを行う。2018/10/28現在では公式にサポートされてる言語がC++, Java, Python, Go, Rusy, C#, Node.js, Android Java, Obj-C, PHP, Dartなどなど多岐にわたる。Rustは非公式だけどプラグインがあるので使える。
gRPC/protocol buffersの個人的なポイントをまとめてみる。
長所:
 サポートされてる言語が多い ツール自体はしっかりしてるのであまりその辺で変にハマることはなさそう streaming通信なんかもサポートされてる protocol buffers自体が後方互換性を命を懸けて守るという強い意志のもとに設計されてる まぁこれはそのせいで面倒なこともあるので短所でもあるけど、多くの人にとっては長所になりうるかと思う protoファイルからドキュメント生成するやつもある(proto-gen-doc) protocol buffers自体は普通にプログラミング言語による型定義みたいな感じで普通に書きやすい(少なくともswaggerみたいな地獄のyaml UXとかに比べたら断然楽)  短所:
 公式ドキュメントが死ぬほど分かりにくい(Googleだからしょうがない説もあるが) ツールのインストール方法などが死ぬほど分かりにくい 現状ブラウザによるネイティブサポートがない(grpc-gatewayを使うといいらしいよ) [追記] (grpc-webというので対応されたらしい) [/追記] 生成するコードにユーザー側の自由度がほぼないし自力でプラグインを書くのは多分大変(のでユースケースによっては全く使えないと思う)  最近はマイクロサービス間通信とかで採用されてる事例が多いみたい。実際にブラウザとの通信で使ってる人はそこまで多くない印象だった。
RustでgRPC Rustでサーバー側の処理を書く。
まず、上にも書いたようにprotoをRustコードに変換するgRPCコンパイラのRustプラグインが必要になる。これにはprotobuf-codegenとgrpcio-compilerを使うといいよってあった。
# インストール $ cargo install protobuf-codegen grpcio-compiler # コンパイル $ protoc --rust_out=. --grpc_out=. --plugin=protoc-gen-grpc=`which grpc_rust_plugin` example.proto これによって生成されたRustモジュールを読み込んで使うことになるけど、それにはgrpc-rsを使った(grpc-rustというのもあるけどこっちは触ってない)。
サーバー側のプログラムはこんな感じで書くと良い。
コンパイルすると、protocol buffersのmessageが定義されたexample.rsと、RPC関連が定義されたexample_grpc.rsが生成される。</description>
      </item>
    
      <item>
        <title>ブログのテーマ(とGitの管理方法)を変えた</title>
        <link>https://myuon.github.io/posts/blog-simplicity/</link>
        <pubDate>Tue, 23 Oct 2018 22:53:56 +0900</pubDate>
        <guid>https://myuon.github.io/posts/blog-simplicity/</guid>
        <description>Git管理が色々あれなことになっており記事を書くのがとても大変なことになっていたので直したかった、ついでにテーマを変えた。
テーマはもともと自作だったのだけれどまぁ私はデザイナーではないのであるやつに乗っかる方が色々便利だということが分かったりした(自分で書くと、状況によって変な空白が出たりとかしがち)。
テーマを変えた Simplicity: https://github.com/eshlox/simplicity
というテーマにしました。シンプルですっきりだけど普通に見やすいと思う(シンプルで見にくいテーマも多いのでこういうテーマは貴重)
細かいところで前のテーマで便利だったけど失われてしまった機能性とかもあるのでそういうのはおいおい対応していきたい。
Gitの管理方法を変えた こっちがむしろメイン。今使ってる静的サイトジェネレータのHugoはGitHubで公式にサポートされてるわけではないので、自分でHTMLファイルを生成する必要がある。一方で、GitHubはユーザーリポジトリ(myuon.github.ioの形のやつ)はmasterブランチがそのまま表示されてしまうのでソースファイルの管理は別ブランチで行う必要があるなどの問題がありめんどいなーと思っていたのだけど、それを解決する方法が分かった。
結論としては次のサイトに書いてあるようなことをやればいい。
 http://kohki.hatenablog.jp/entry/hugo-portfolio https://qiita.com/kwappa/items/03ffdeb89039a7249619  masterブランチを殺して、代わりに git subtree push --prefix docs/ origin master とか叩くことで/docsをorigin/masterにpushできる。origin/masterって消せるんですね、知らんかった。
というわけで、よくわからないsubmoduleの管理などせずとも(gitのsubmoduleって結構難しい機能だと思う、いつもいまいちよくわからんって言って使ってたし結構気をつかわないといけなかったりする)、簡単にHTMLの管理ができるしpublishも1コマンドでできるしで便利～になった。
実はこの辺の問題があって最近はブログ記事を書けていなかったのだけれど、環境をえいやと整えたのでまたなんか書いていきたいと思います。
そういえば私は飽きっぽいので今までいろいろなプロジェクトを始めては途中で飽きてやめたりしてきたが(ここ7年くらいでGitHubリポジトリの数は58になった)、最近は昔やってたやつを引き継いでまた始めたりということもちょくちょくやるようになったりしている気がする。良い傾向だし、そういう感じで過去に挑戦したプロジェクトのサルベージやら供養やらも自然にやっていけたらいいなと思ったり思わなかったり。</description>
      </item>
    
      <item>
        <title>VSCodeでIsabelle2018環境構築</title>
        <link>https://myuon.github.io/posts/isabelle-vscode-2018/</link>
        <pubDate>Sat, 28 Jul 2018 11:46:33 +0900</pubDate>
        <guid>https://myuon.github.io/posts/isabelle-vscode-2018/</guid>
        <description>こうなるよ スクショ
 環境構築 ほぼこれにある通りでOK
https://marketplace.visualstudio.com/items?itemName=makarius.isabelle
Isabelleのインストール http://isabelle.in.tum.de/devel/release_snapshot
から対応するプラットフォームのファイルをダウンロードして展開しとく
VSCode pluginのインストール  Isabelle Prettify Symbols Mode bibtexLanguage (optional)  を入れる
VSCode config user configを開いて次を追加
&amp;#34;isabelle.home&amp;#34;: [Isabelle2018のルートへのパス], VSCodeをリロードすると、初回であればビルドが走って、それが終われば&#34;Welcome to Isabelle ...&#34;って出る
これで環境構築はOK
対応状況 VSCodeサポートは残念ながら完璧とはいえない
 state: VSCodeで Isabelle: Show State しましょう, output panelが出る(白背景に勝手になるんだけどこれは設定できないのだろうか, ダークテーマだとつらい) syntax highlight: これは問題なし unicode symbolの入力: \&amp;lt;forall&amp;gt; とかで入力できるが結構カーソル移動の制御とかがキモイ, あと !! とかの入力方法が分からない(記号のままだと正しく変換されない) sledgehammer: vampireがnot activatedなのでvampire_noncommercialをyesにしろってメッセージが出てvampireが使えない. 設定方法は不明だが他のproverは使えるのでまぁセーフか？ 他panel: Query, Sledgehammerパネルはまだない模様 一部state画面に出ないものがある: solve_directのメッセージとかが出てくれない. 対応する箇所にエディタ側で下線が引かれてマウスカーソルをあてるとメッセージが出たりする(けどちゃんと対応してほしい)  一方でVSCodeがベースなのでauto-completionのUIが使いやすい(というかjEditが本当にひどかった)とか, VSCodeのemacs keybind pluginは出来がいいので快適にemacs keybindで証明が書けるなどのよさがあります.
使っていきたい</description>
      </item>
    
      <item>
        <title>静的解析の限界、現実世界との境界</title>
        <link>https://myuon.github.io/posts/how-far-can-static-analysis-go/</link>
        <pubDate>Wed, 11 Jul 2018 05:49:39 -0700</pubDate>
        <guid>https://myuon.github.io/posts/how-far-can-static-analysis-go/</guid>
        <description>はじめに 2018年に静的解析をとにかく強力につけまくるのは多分あんまりコストに見合わないのでよくない
じゃあ静的解析を窓から投げ捨ててよいかというとそれはただの愚行
(以下、静的解析を普通に使えてる人には自明なことしか言いません)
依存型のつらみ 私が最初に静的解析の限界を感じたのは多分依存型で遊んでいたとき
依存型の力はすごくて、まぁそれもそのはず命題論理から述語論理に進んで元への言及ができるので見かけ上表現力はとんでもなく上がるわけです。例えば「ある方程式を満たす解のみを受け取って何かする」みたいな関数が型として表現できるようになる。
一見すると最強に見えるんだけどこれは実質定理証明をすることなので、制限の強い型をつければつけるほど実装で苦しむ羽目になるということを割とすぐ痛感することになった。
例えば head : Vect (Suc n) a -&amp;gt; a で長さ1以上のvectorの先頭を安全に取り出す関数を表現できる。 これはコンストラクタを見るだけなので実装も簡単ですね。 それでは今度は quick_sort : (xs: Vect n a) -&amp;gt; \exists (ys: Vect n a). Increasing ys /\ Isomorphic xs ys (読み方としては、長さnのvectorを受け取って、「長さnのvectorであって、昇順に並んでおり、適当に順番を入れ替えるとxsに一致するもの」を返す関数と読みます)とかどうかというとまぁこれを見てすぐ実装が思いつく人はいないでしょう。
やってみると分かるがこれに実装を与えるためには相当な定理証明力を要求される。もはや関数型プログラミングですらない、単なる定理証明である。
とか言う話は↓にもよくまとまっているのでよければ読んで
 問題を解決するつもりでキッチリ型を付けた先にある高い壁 - ぼくのぬまち 出張版 実世界を扱う依存型プログラミングのたぶん基本～外界から安全な世界までの道 - ぼくのぬまち 出張版  Welcome to 現実 上の記事にも書いてあるんだけど、実は依存型のつらみはこれだけではない(そして今回の記事はむしろこっちの話を書きたい)
例えば先程のquick_sort関数をめでたく実装できたとしよう、すると我々はwell-sortednessが証明されたquick_sortを手にしたことになる。素晴らしい！ではこのquick_sortを使ってみよう！
普通のアプリケーションであればquick_sortにはリストを食わせた後そのまま普通に使ってデータとしては捨てられてしまうかもしれない。quick_sortから返却されたリストが 昇順に並んでいる ことが保証されていなければならないアルゴリズムを書く人がどれだけいるのだろうか？ もちろんソートされていなければ後々まずいことになるということは往々にしてあるが、それが至るところに出現するということはあまりなさそうだ。数百行のプログラム中で1-2ヶ所、たかがその程度だろう。 quick_sortを実装するために支払ったコストは本当にここの嬉しさを上回るのだろうか？
あるいは、もっとひどければ全く利用されないこともある。ソートされたデータを一度DBやファイルに書き出してしまえば、型の保証はなくなってしまう。ファイルに書き込まれる前にソートされたことが型で保証されていたデータは、ファイルから読み出したときにはすでにその保証を失っている。
実際にはシステムレベルでの保証というのがある。ファイルに読み書きされると当然型による保証は失われてしまうが、「そのファイルがこのプログラム以外で読み書きされないことを仮定してよいのなら」ソートされたデータを書き込んだファイルは再び読み込むとソートされているとしてよいはずである。 というわけでプログラムの型レベルでは保証できなくとも、 システム全体がまともに動いているなら ちゃんと制約を満たしてくれているはず、というのがある。
システムレベルでの「保証」とは人間の頭の中にしかなく、通常いくつかの仮定が必要であるので型システムではうまく取り扱うことができず、例えば unsafeCoerce : a -&amp;gt; b のような関数の出番ということになる。</description>
      </item>
    
      <item>
        <title>責務と層の分離</title>
        <link>https://myuon.github.io/posts/architecture-basic-idea/</link>
        <pubDate>Tue, 10 Jul 2018 02:49:04 -0700</pubDate>
        <guid>https://myuon.github.io/posts/architecture-basic-idea/</guid>
        <description>設計の話 設計の話です。
責務 責務、誰がその仕事を行うかということを考えましょうというのはまぁさんざん言われていることだけど実際大事だと思う。
テクニックとしては委譲だのなんだのとあるけど、結局は「その仕事はその人に任せて本当にいいの？」にYesと答えられる場合にのみその作業をそのモジュールなり関数なりクラスなりに任せましょうという話ですね。
層の分離 プログラムが行う仕事は通常いくつかのオペレーションを組み合わせて実現されるわけだけど、それらの重要度というのは普通は一様ではない。
仕事によってはドメインレベルにしっかり固定されそれ以外のオペレーションがあり得ないものもあるし、今は一旦こうして実装しておくがあとで高確率で置き換える必要があるとかそういうやつ。
例えば今はハードコードしているが設定ファイルから読み込んだ値にしたい、DBを切り替えたい、データの中身が変更したいとかそういう感じのやつ。
そういうときに、それが所属する層を分離するという手法がたまに取られる。 DIが必要になる設計手法とかだとおなじみだけど、後から値を切り替えたいものはより外側の&#34;層&#34;にそれを押し出し、逆に変更が発生しないところに関してはより内側の層にそれを閉じ込めるというやつ。
責務と層の分離 なんでわざわざこういうタイトルをつけたかと言うとこの2つの意識が一番大事かなと最近思うようになったから
責務をはっきりさせることと層を分離するってことをひたすら繰り返すだけで大抵の設計手法はやっていけるような気がするなぁと思ったりした
GoFのデザインパターンをチラ見して 本は読んでないのだけど、最近GoFのデザインパターンについてどういうものかを調べたりしていた。
一応目的としてはデザインパターンが解決しようとしている問題を明らかにしてモダンな解決策を探りたいというのが動機としてあった。
感想を正直に書くとまぁ基本的には内容が古い上にまとまってないしこれは名前つけるようなものじゃないだろというのが多い感じで2018年にわざわざ勉強する必要があるようなものではないなと思ったりしたという感じにはなるが、それはおいておいて デザパタのあれこれを調べていくうちに、上のような2つの点の大切さを認識したりした。
デザパタの多くは現代的な言語なら責務と層の分離がちゃんとできてたらほぼ問題にはならない気もする(こういう話も具体的な言語を固定して考えたりしてみる記事を書いてみるべきかもしれない)。
オブジェクト指向/DDDとか 「オブジェクト指向は設計ではない」と繰り返して言っていたら何かの折にDDDに触れる機会があり、「これは良いものだ」と思ったりしたことがあった。
[追記]DDDのlayerに関して適当言ってたので消しました。[/追記]
実際にDDDはドメイン駆動〜みたいなことを言っているが自分はそこで初めて層の分離の概念を得た。 DDDではドメイン層と〜 DDDのことはよく知らないんだけど例えばClean ArchitectureではEntity層, UseCase層, Adapter層, Driver層のように中にあるべきものと外に置くべきものをはっきり区別していたのが、オブジェクト指向でスパゲッティ設計を生み出し続けていた自分にはとても素晴らしいものに見えたというのがあった。
オブジェクト指向がなぜ設計ではないかということは、今にして思えばオブジェクト指向は責務については問題にするものの(あるメソッドをどのクラスに入れるべきかという話はよく問題に上がるが)層の概念がないので縦方向への広がりがないというのが大きな問題としてあったのだろうということが分かったりした。
終わりに 内容がない</description>
      </item>
    
      <item>
        <title>HaskellでDIする</title>
        <link>https://myuon.github.io/posts/haskell-di/</link>
        <pubDate>Fri, 06 Jul 2018 05:51:00 -0700</pubDate>
        <guid>https://myuon.github.io/posts/haskell-di/</guid>
        <description>DI DIの重要性はここ数年で急速に高まってきている。 依存性が注入されたりとかそういうことはどうでもよくて、設計と実装を分けたい、人類はそれだけのために色々と工夫をこらし最終的にたどり着いたのがDIであったのだろう。
Haskellでも設計と実装を分けるためにDIしたいというのは自然な流れである。
ここでは型も含めて設計が実装に依存してはいけないということを要求する。 例えば設計でMySqlConnection、みたいな型が出現することも分離できていないので禁止とする。
問題点 設計を定義するときには他の言語ではインターフェイスなどの仕組みが使われることが多い。 Haskellには型システムという仕組みがあるのでこれがインターフェイス相当の機能として紹介される場合がある。
しかし型システムはインターフェイスとは違い、型を固定する仕組みがない。型クラス TypeClass a のインスタンスの値が x:TypeClass a =&amp;gt; a と y:TypeClass a =&amp;gt; a のように2つ与えられたとしても、xとyが同じ型である保証はないし、これが同じ型であることを強制するためにはxとyを同時に作って常に同時に運ぶ必要がある。
というわけでインターフェイスを使うと型が固定できないのでDIしようとすると困ったことになる、と私はずっと思っていた。
存在型とreflection 型を固定する仕組みは実はどうにかすることができて、要は存在型を使って data Trapped = forall a. TypeClass a =&amp;gt; Trapped a とやると型を外から見えないように隠蔽することができる。
存在型は中を開いたときにもともと何が入っていたかはわからなくなるが、設計ではそれを意識する必要がないはずなので特に問題がない。
さらに、いわゆるDIコンテナ的な仕組みでは生成したオブジェクトを必要なところに注入してくれるという機能があることが多いが、実はこれと同じこともHaskellではできる。
reflectionというパッケージがあり、これはconfigデータを外から与えるためによく使用される。 Given a =&amp;gt; ... なる型をもつプログラムは given と書くといつでも好きなタイミングで外から挿入されたaの値を取り出すことができる。
同じ型に対しては1つの値しか注入できないが、実際にDIするときは利用する型は1つだけなので問題がない。
というわけでこれでHaskellでもDIできそう！ということが分かる。
Loggerの例 例えばLoggerを作る例を考える。
設計 class Logger a where writeLog :: a -&amp;gt; String -&amp;gt; IO () ロガーは文字列を受け取って何かするというインターフェイスを実装した型のことであろう。ここでの a に、具体的なLogger型が挿入される。
data SomeLogger = forall a.</description>
      </item>
    
      <item>
        <title>Fluxを再発明する</title>
        <link>https://myuon.github.io/posts/refluxible-library/</link>
        <pubDate>Sat, 16 Jun 2018 08:00:49 -0700</pubDate>
        <guid>https://myuon.github.io/posts/refluxible-library/</guid>
        <description>Haskellの2D graphics libraryを作った 作った: refluxive
与太話に興味がない人は解説まで飛んでください
なにこれ 大体Haskell製Fluxベースの2Dグラフィックスライブラリ on SDLという感じの代物です。
なぜ 大変悲しいことにHaskellではゲーム用に気軽に使えるグラフィックスフレームワークがないことがよく知られているわけです。 候補としては一部のFRP系のやつ、あとDSL系のやつも少々(これは用途がかなり限定されていることが多いけど)、それと今ならElm(!)が下手すると最有力かもしれない。 一応本当に簡単な用途ではglossがそれ系を標榜しているがフレームワークではないし、真面目に使うには多々至らぬ点も多く…という感じなので困った困ったになるわけですね。
---
なぜフレームワークがほしいかというとUIを一から作りたくないというのがある。私はあと何回「ボタン」をrectangleとfillRectangleとtextを組み合わせて一から作らないといけないんだ。 画像を読み込んできて3x3マスに分割して「レイヤー」として表示できるようにするみたいなのも何回も書かされたのでもう散々という気持ちがあった。
グラフィックスライブラリは別にOpenGLでもSDLでもGLFWでもなんでもいいんだけど一からUI部品を作っていると日が暮れてしまうのでそういうUI部品をライブラリとして提供したくて、じゃあUI部品を共通して作って提供できる仕組みをどうにか考えないとなぁという感じになってた。
Flux JavaScript(クライアントサイド)業界ではこの辺をみんな真面目に考えて色々やっていってるわけですがまぁ最近はFluxの影響を受けたやつが人気なので私もそういうのにのっかる感じにしました。 といっても完全なFluxでもないと思う。ViewがModelの射影になっていること、Viewへの変更がSignalとして送出されてModelの方に伝わるみたいな感じになっているのは大体Fluxだけど、dispatcherではなくSignalの送出はベースのUIモナドが一括で請け負ってるとことかはちょっと違うような気もする(詳しくないからよくわからんけど)。
Haskellとは HaskellでFluxぽい仕組みがちゃんと乗っかるかは若干不安だったけど特に問題はなかった。そもそもこっちはDOMを操作する必要がない、何もない代わりに何にも縛られないのでまぁ自由は効くよねという感じ。 Haskellらしいコードになったかという意味では、default-extensionsを見てもらえばまぁ察しはつくと思う。今回はExistentialQuantificationとTypeFamiliesとDataFamiliesを使いまくったのでHaskell(GHC)でこそという感じはしてるような気もする。
テクいところ 最近Rustに浮気しっぱなしだったからHaskell真面目に書くの実はそれなりに久々だったけど、ちゃんとRustや他で勉強したりしてたことが活かせたりはしたと思う。 performGCとかunsafeCoerceとか今までどう使っていいかよくわからなくてやってなかったけどちょっと分かってきた感じもありよかった。
refluxive ライブラリの中身を超簡単に解説します。 「ほーんHaskellではそうやってやってるんだー」くらいで見てもらえればいいと思います。
あと当たり前だけどまだプロトタイプができたてのライブラリなのでAPIは将来変更されるおそれが大いにあります。
構成要素  Component: 1つの部品を表す単位; 中にModelとかそういうのが定義されているが外からは見えない Model: Componentの内部状態 Signal: Componentから送出されうるメッセージ 他のComponentはSignalを監視して非同期にcallbackを実行したりできる ComponentView: Componentをインスタンス化したやつ、モデルのデータそのものとかuniqueな名前とかが入ってる Graphical: Viewの表現 UIモナド: Componentの操作とかを実現するためのモナドで、Componentの管理、送出されたSignalの配信などをやってくれる  例:ボタン とりあえず例をやろうということでボタン。
https://github.com/myuon/refluxive/blob/73c498186d9d5ab911f97332e261b87ca86e8cd4/example/Button.hs
動作例は次のようになります
ボタンのめんどくささよ pic.twitter.com/ImMyAwXJ7G
&amp;mdash; みょん (@myuon_myon) June 16, 2018 
Component Componentはbuttonとappの2つ
まずbuttonから。
data ButtonState = None | Hover | Clicking deriving Eq instance Component UI &amp;#34;button&amp;#34; where type ModelParam &amp;#34;button&amp;#34; = Record [ &amp;#34;label&amp;#34; &amp;gt;: T.</description>
      </item>
    
      <item>
        <title>私と型システムとポエム</title>
        <link>https://myuon.github.io/posts/type-system-poem/</link>
        <pubDate>Sat, 02 Jun 2018 08:27:31 -0700</pubDate>
        <guid>https://myuon.github.io/posts/type-system-poem/</guid>
        <description>最近巷では俄に型システムについての言及が増え、型システムポエマーが増えてる気がするので自分もその時流に乗りたい。
完全にポエムだけどなんかあったら随時指摘ください。直します。
TL;DR 言いたいことはまとめると次
 型システムは程度問題なのでちょうどいいところを探すべき 型は万能でも強さが正義でもない(だから未だに研究されてる) よく知りもしないくせに計算機科学を侮辱するのはやめろ  予防線 あくまでポエムですので中身はないです
私は型理論専攻で学位はとったものの研究者ではないのであまり信用しすぎないように
型システムの過去 型システムは大まかに次のような利点があるとされてきた(個人的主観)
 「異常」なプログラムを検出する仕組み 静的解析による分かりやすいエラーメッセージ 型そのもののドキュメント性 IDEでのcompletionに貢献 最適化に貢献 (数学に正しく裏打ちされたsemantics)  型システムの分類と主な特徴 当たり前だが型付き言語も一枚岩ではなく、色々違いがあるので少し分類をしておく。下に行くほど強い。
型なし(動的型)言語  言語: untyped lambda calculusやLL系言語など  LL系とは言ったものの例えばPythonは最近type annotationがかけるし、あるいは型のない言語でもIDEが静的解析を行い実質型システム相当のチェックを行う言語があったりするので型の恩恵を一切受けない言語はイマドキそう多くはない。 型システムの人間からは型なしは型なしとして一緒くたにせざるを得ないが、別に型なしを嫌っているわけではない。それも一つの言語の在り方である。まぁ私は死んでも書きたくないけどな。
クソザコ型(データサイズアノテーション)言語  言語: C  かつて非型システムの人間にとって「型」とはこれであった。今でもこれを型システムと思ったまま脳みそがアップデートされていない人間もいると思う。 要は変数にint, floatなどのアノテーションがつき、これは実行時のその値のデータサイズを表す。 大半の型付きの言語はこの機能を内包しているが、これはあくまで現実のコンピュータのアーキテクチャに寄り添ったエンジニアリング的観点により導入されることが多い。 これを型システムと呼んでもいいかは諸説ある。私は呼ばない。
割と単純な型をもつ言語  言語: simply typed lambda calculus、関数型はあるがジェネリクスを入れてないような一部の言語  ジェネリクスを入れると考えることが多くなるのでこの辺で落ち着くという選択肢もある。Goとかはこれかな？(よく知らないで言ってる)。 すごく単純なプログラムしか書かないなら、静的解析も楽でコンパイルも早くそれなりに型の恩恵も受けられてよい落とし所だと思う。ただライブラリを作る人にとっては抽象化への障壁が大きすぎると感じるかもしれない。
頑張れば型推論の決定性を保てる言語  言語: OCaml, Java, C#など  多くの(現場で使われるような)静的型付き言語はここに属することが多い。 (実際はいろいろな事情によりできてない言語が多いが)OCamlに代表されるようにジェネリクスとサブタイピングまで入れても型推論は決定的にできる。 型を人間は書きたくないが抽象化はさせろという人にとっては最も都合の良い着地点になる。現状多くの人に受け入れられているように見えるので成功した型システムの一つと言っていいと思う。 この言語ではオーバーローディングなどの型推論を阻む仕組みに対してどのように対抗するかというのが大きな問題になる。現状では政治力と運用でカバーしていることが多いような気もする。
typeclass/rank n types/higher kind polymorphism言語  言語: Haskell2010, Haskell(GHC), Scala  型推論の決定性を窓から投げ捨てて暗黒面の力を手に入れたやつ。OCamlは職人技のような言語デザインで決定性を保っていたのでそこに少し拡張を入れたり少し条件を緩めたりするだけであっという間に暗黒面に堕ちてしまうので意図せずこっちに転がってる言語もたまにある。 明確に意図してここに足を踏み入れた言語は(実用面でも使える言語となると)限られてくるが、型推論を気にせず理論的に便利な道具をたくさん追加できて気持ちよく型レベルプログラミングとかで遊べるようになる。 しかし暗黒面と称されるようにここから先は地獄である。依存型の誘惑を振り払うのは難しい。</description>
      </item>
    
      <item>
        <title>Desktop Linux VM環境 on Windows</title>
        <link>https://myuon.github.io/posts/vm-linux-on-windows/</link>
        <pubDate>Sun, 20 May 2018 08:11:42 -0700</pubDate>
        <guid>https://myuon.github.io/posts/vm-linux-on-windows/</guid>
        <description>はじめに 私はプログラミングはすべてLinux環境でやっている。環境構築、フォントレンダリング、まともな端末など理由を挙げればキリがない。 最近までDesktop Linuxを直接インストールしていたが(Windowsを持っていなかったが)、ゲームがしたいなどの理由によりWindows 10を買ってクリーンインストールしたのでLinux環境をVMに移行した。
結論 Vmware Workstation Playerを使え
Vmware Player vs VirtualBox vs Hyper-V 仕組みの上ではHyper-Vは他2つに比べてハードウェアに近く、よいパフォーマンスが得られることが期待される。 が、3つを試した上では圧倒的にVmware Player  VirtualBox  Hyper-Vという感じだった。
環境
 ホスト: Windows 10 ゲスト: Ubuntu 18.04 Gnome/Xfce ゲストの設定: メモリ4GBくらい 4コア使っていいよぐらいの設定 特に細かくいじったりはしてない  結果
 Hyper-V: 入力遅延が大きすぎて使い物にならない、マウスもキーボードも数フレームは遅延してる。あと3つの中では明らかにこれだけ重かった(Gnomeのアニメーションの挙動とかを見ている限り)。Hyper-VのViewerがボロいのかと思ってRDP接続も試したけどVirtualBoxと比べても明らかに重くパフォーマンスが出てなかった。LISはUbuntu 16版のものを使用、BIOSでC-State切るといいよって言われてそれもやったけど効果ほぼなし。 VirtualBox: 比較的サクサク。Gnomeだとちょっと重いがXfceだと普通に快適。VMの起動と終了がちょっと重いかなくらい。 Vmware Workstation Player: 3つの中では最もサクサク。Gnomeのアニメーションもそれなりに反映されていた。Xfceにしたら本当に早い、実機インストールかと錯覚する快適さ。体感ではVMの終了がVirtualBoxより早い。  試すとわかるけど悩むまでもないという感じ。 ただしVmwareのみディスプレイサイズがホストOSのものに勝手に従ってくれなくてxrandrからaddmodeした。
そもそもプログラミングするだけならDEいらないんじゃないですかという話もあるけど今はGUIアプリケーション開発してるからそうも行かないんだよな〜って人の話です。</description>
      </item>
    
      <item>
        <title>動画編集ソフトを作り始めた</title>
        <link>https://myuon.github.io/posts/madder-start-to-create/</link>
        <pubDate>Sun, 04 Mar 2018 19:21:20 +0900</pubDate>
        <guid>https://myuon.github.io/posts/madder-start-to-create/</guid>
        <description>Rustを使い始めて1ヶ月だぜ体験記みたいなのを書こうとしたけどせっかくなので今やってることも全部まとめて1本の記事にすることにした。
最近日本語をかくのがめんどくさい以外の発言をしていない気がする。
1ヶ月ほど前に動画編集ソフトを作りたくなって、言語はRust メディアフレームワークにGstreamer GUIにGTK+を使うのだけどこの3つをどれも触ったことがない状態で作り始めるという完全に勢いだけのアレというのが前置き。
Rust 前回の記事でも色々言ってたけどその後分かったことなんかを記しておく(本当はWHAT I WISH I KNEW WHEN LEARNING RUSTみたいにしてまとめると良いのだろうなぁ)
 とりあえずメモリモデルとしてはスタックとヒープがあるということだけ分かっておけば大丈夫そう structのフィールドに参照をもたせるとlifetime parameterにコードがまみれるのでやめたほうが良さそう Rc&amp;lt;RefCell&amp;lt;T&amp;gt;&amp;gt; が便利(これは主にGTKを使う時に必要になったというのもある) Rc&amp;lt;RefCell&amp;lt;T&amp;gt;&amp;gt; は確かに便利だけど hoge.borrow_mut().call(hoge.borrow()) みたいなことをするとBorrowMutError: already borrowedで実行時エラーになって死ぬので気をつけよう 参照が欲しいときはBorrow, BorrowMut, AsRef, AsMutトレイトの実装があるかを見よう Derefトレイトは神 Fn, FnMut, FnOnceの意味がようやく分かってきた FnOnce系はちょっと気をつけたほうがいい(Option::unwrapがselfを消費するのとか) trait, implは飽くまでインターフェイスの提供だけなのでデータの扱いはstructで行う OOPっぽくコード書きたいときはtrait objectと動的ディスパッチの仕組みを上手く使う(果たしてこれが正しいアレなのかはよく分からん) マクロは便利 別言語でtrailing commaで怒られると厳しい気持ちになる if letが意外と便利 言語拡張が結構カジュアルに欲しくなるのでこのままだとnightlyしか使わなくなりそう 文字列リテラルが常に&amp;strなのは意外とパターンマッチの時にめんどくさい マジでViewPatterns拡張が欲しい マジで 大抵の他の言語でもそうなんだけどasって書くのめんどくさい あと as (i32,i32) って書けないの割と不便 前は「ブロックをclosureや関数として切り出してくると怒られるの理不尽💢」みたいなことを思っていたのだけれど、closureや関数は複数回呼ばれる可能性がある上に呼ばれるタイミングが不明なので所有権をちゃんと考えないといけないということが分かりスッキリした  最近Derefは神だなと思うことがあり、今まで(なんでこれ型が合うんだろう〜)って思ってたところは大体Derefのおかげであることが分かったりした。
例えば hoge: Rc&amp;lt;RefCell&amp;lt;T&amp;gt;&amp;gt; に対して hoge.borrow(): &amp;amp;T で一発でTへの参照が得られるんだけど、これは (*hoge).borrow() が勝手に補われており、更にRcのDerefの実装は中身への参照を取り出すようになってるからいい感じに出来るというのがある。
他にも、Rustは基本的にexplicitな言語であるけれどDerefだけは暗黙に色々やってくれるのでこいつのおかげで知らぬ間に記述が楽になってるところがあったりした。便利っぽい。
思ったよりいいたいことがなかった。最近Rustの勉強と言うよりGTKとかの勉強に時間もコストも取られてる感あるからかなぁ。
GTK+ gtk-rsというプロジェクトがありGTK関係のライブラリを色々提供してくれているので使ってる。たまに対応してないAPIがあるのとドキュメントにfeatureの指定が書いてないのでたまにハマる。
 gtk: gtkのガワ widgetとかを提供する gdk: 中身？ 内部実装のあれこれを提供する cairo: 2Dグラフィックスライブラリ pango: フォントレンダリングライブラリ pixbuf: cairo等で扱えるpixel buffer githubのイシューにもあるんだけど登録するcallbackがほぼ&#39;staticを要求するのでコード内の状態をcallback越しに持っていけない それを解決するために Rc&amp;lt;RefCell&amp;lt;S&amp;gt;&amp;gt; が必要になる widgetが色々あるようで実はそんなにない ちょっと凝ったことするなら自作するしかない widgetは内部状態を持っていてそれ自体がMVCみたいな感じになっているのでデータの持ち方を中央集権的にしようとすると結構めんどくさい Elmの人も言っていたが何でもコンポーネントは(ライブラリは作りやすいけど)あんまりいい設計ではない気がする ViewはModelからの単なる関数にしたほうが素直 ドキュメントが豊富なので頑張って読めば意外となんとかなる(ただし本家以外は基本アテにならない)  Gstreamer gstreamer-rsというライブラリがある。これもたまに対応してないAPIが(ry</description>
      </item>
    
      <item>
        <title>Rustに入門した</title>
        <link>https://myuon.github.io/posts/rust-started/</link>
        <pubDate>Fri, 09 Feb 2018 22:21:42 +0900</pubDate>
        <guid>https://myuon.github.io/posts/rust-started/</guid>
        <description>Rustに入門して2週間くらい経ったぜ
TL;DR Rustは普通に便利ないい言語
入門した 入門にあたってはプログラミング言語Rustを読んだ。これの翻訳版ぽい。
読んでRustに対して思ったこと:
 読んだやつは古いドキュメントの翻訳版だったようで一部記述が古いっぽかった 構文はシンプルだけど必要なものは揃ってる感 ML風でADTもパターンマッチもあるしtraitもあって言うことナシでしょ 所有権とか借用とかそういう聞いたことあるワードは参照という概念に対するアレっぽい ｽｨｰ言語を気軽に(unsafe)呼べるのはFFIするとき良さそう 強そう マクロ割と便利そうな雰囲気ある RcとかArcとかCellとかいう便利なものがあるらしい あとBoxはいつ使うんじゃ 参照わかったようでわからない とりあえずスタックとヒープの違いは覚えたぞ 入門書なのに普通にするする読めてしまったし特に難しいことがなかった、もしかしてRustは簡単なのでは？？？  参照とかいう概念がある言語を長らくやっていなかった(Pythonは基本参照だった気がするけど意識する場面ないしHaskellの参照もあんまり使わないしなぁ)ので 「あー参照だとこういうことも考えないといけないのかぁ」って思ったりした
参照、人類には早すぎるのでは？？？って感じ
ちょっと書いたりした ちょっと書いたりした(してる)
どうせなのでなんか作ってみるかぁと思ってgstreamerとGtkで動画をごにょごにょするアプリケーションを作って遊んでる。 なんで入門していきなりそんな重いもの作ってんだよという感じなのだけどRustの強みはやっぱりCにFFIしやすいことな気がしていて逆にHaskellでは現状まともにビルドできてまともに使えるGUIライブラリがないので、そういう意味で(Rustの強みを活かせるという意味で)GUIアプリケーションぽいものに着手した。
まぁまだそんな書いてないしな〜(と思ったがすでに700行近い。Haskellなら500行超えるだけで相当だけど中括弧でブロック表す上に手続きがデフォルトの言語ってめっちゃ行数かさむよね。)
しばらく書いた感想:
 エラーメッセージがカラフルや…なんだこれ…(GHCも最近カラフルになったけど未だに慣れない感ある) ｽｨｰ言語と違って コンパイラが信用できるーーーﾔｯﾀーーー(踊りだす) エコシステムが強すぎてビビる(いやHaskellがダメなだけか…？) Rc Cell RefCellあたりがあまりに便利 所有権意識する場面あんまない *(スター)はRustが勝手に補ってくれるって書いてあったので一切書いてないんだけどいいのかこれで 結局*が何者なのか未だによくわからない そもそも自分はHaskell出身だからmutとか使う場面あんまないな そりゃ苦労しないはずですわ FFIするのはほんとにシームレスで強さしかない 参照、人類には早すぎるのでは？？？？？？ ポインタだとコンパイル時にアドレス分の長さしか食わないがデータによってはコンパイル時にその長さが分からないみたいなエラーを見て、長さがわからないとallocateができない！そういうのもあるのか！になった lifetimeの存在により自然にステートの管理の意識がブロックに宿るようになるの結構すごい 人類はステート管理に対する新たなやり方を手に入れたのでは？ってちょっと思った もしかしてRustは簡単なのでは？？？？？？  所感 巷では難しい言語だみたいに言われることがあるような気がするけどめちゃくちゃ簡単やんけ！と思った (自分は特殊な人間である自覚はあるので大方の人には難しいのかもしれない)
というか、たしかに所有権を完全にコントロールして正しい設計を導き出すのは難しいんだけど、それは参照とかいう概念が全て悪いのであってRustはむしろそれを管理するための適切でhuman-friendlyな方法を提供してくれてるしすごいいい言語じゃん！と思ったりした
あとコンパイラを全面的に信用できるのも大きい。雑なことしてもどっかおかしかったらコンパイラが教えてくれるしな！という感じでガシガシ書いていける。
「higher kind typeがない」って言うのは聞いてて自分は今の所なくていいんじゃない？派なんだけどやっぱ場合によっては不便なんだろうか。 HKTって実装のコストと学習コストの肥大化の割に恩恵が大したことないというイメージだし、どうせHKT入れても次はアレをいれてくれコレもいるだろみたいになるのは必至なので(型システムとはそういう宿命なのだ)今の小さくて十分パワフルなRustでいいんじゃないでしょうか。
それでも自分はHaskellの方が圧倒的に慣れてるのもあるので、敢えてRust使うならやっぱGUI方面かな〜(RustはFFI強いし楽だし一方Haskellは全然ライブラリメンテされてないし)と思ってる。 まーでもmakeLensesしないとまともなレコードも使えない某言語を頑張って使い続ける理由はあるのだろうかというアレも。 やっぱRustに比べるとHaskellは難しい言語だなぁと思いますね。
以上</description>
      </item>
    
      <item>
        <title>Namespace Haskell</title>
        <link>https://myuon.github.io/posts/namespace-haskell/</link>
        <pubDate>Sun, 04 Feb 2018 13:55:38 +0900</pubDate>
        <guid>https://myuon.github.io/posts/namespace-haskell/</guid>
        <description>Haskellにモジュールシステムが欲しすぎたのでNamespace Haskellとして提唱したい。
主な機能 open import Agdaにもある機能で、importをimport(モジュール読み込み)とopen(現在のコンテキストに名前を公開)に分割する.
 import M とすると, M.func によってモジュールMの関数funcにアクセスできる open M とすると, それを指定したブロックでMの関数を修飾子なしでアクセスできる open import M とすると, import M; open M の意味になる(現在のHaskellのimport)  openをwhereブロック内で宣言することで、一部でしか使わないimportをあっちこっちで展開するのを防げる。
public export 現在のHaskellではモジュール宣言時に module M(..) where でexportする関数を選べる。
そして module M where は全て公開の意味になるが、これを全て非公開に変更し、モジュール内で export (..) のように宣言したもののみexportすることにする。
associated function 要は「メソッド」機能なんだけどtypeclassの関数のことをメソッドって呼ぶことがあるような気がするので名前の衝突を避けるためにここではassociated functionとよぶ.
次のような、データ型とそれに対する特別な関数定義を行うスコープを用意する。
-- 例 data List a = Nil | Cons a (List a) impl (this :: List a) where { reverse :: List a reverse = .</description>
      </item>
    
      <item>
        <title>プロジェクトマネジメントを始めたい</title>
        <link>https://myuon.github.io/posts/want-to-start-project-management/</link>
        <pubDate>Sun, 14 Jan 2018 23:14:19 +0900</pubDate>
        <guid>https://myuon.github.io/posts/want-to-start-project-management/</guid>
        <description>資料  担当になったら知っておきたい「プロジェクトマネジメント」実践講座: 2ヶ月前くらいに買って読んだ ゲーム開発 プロジェクトマネジメント講座: スクエニの資料 具体例がゲーム開発だけど内容は業種を問わないと思う  プロジェクトマネジメント実践講座を読んだ 内容は大変丁寧な感じでモチベーションと具体的な例を上げつつPMの重要性、あと必要な各種書類や仕事の詳しい日本語による解説という感じ。 それなりにページ数あるけど圧縮したら15ページ+図表くらいで収まる気がする(チートシートほしい) モチベーションを十分理解している人は安心して読み飛ばしていいと思う。
個人的な感想
 PMでは「納期を守る」という感覚が一番大事っぽい やたらExcelを推してくるのは逆に言えばまともなツールが他にないのだろうなぁ リスク管理についても書いてあってなるほどと思った(リスクを先に想定しておくのは難しいけど大事っぽい) モチベーションの説明がわかりやすい プロジェクトの発足と仕事を作って人に割り振る時のマネージャーの動き方について主に書いてる感じ  読んでる時はもっと色々思ったはずだけど読んでから時間経ちすぎて忘れた
個人的に気になった方法論 「PMの話」っていうと結構マネージャーの動き方とか仕事の仕方的なものを指すこともあるんだけど(サイクルはこまめに回しましょうねとかそういう) 自分が欲しいのは方法論なのでそっちについてちょっとまとめておく
WBS &amp; ガントチャート 各node Xに対しXを作るのに必要なもの/作業を子nodeに置いた高さ4のfin. branching treeをWBSと呼ぶ(めちゃくちゃかっこいいなこの説明って思ったけど誰にも伝わらないと思う)。 WBSに実際のスケジューリングを与えるものをガントチャートという。
これらを作るのは自然なことなのだけど、問題は実際の作業の間には依存関係があることで、これを上手く管理するのは結構難しい。
基本は依存関係に沿ってトポロジカルソートして作業を進めればよいがそういうことが簡単にできるツールって意外と少ないよな 本ではExcelって言ってたが果たして
重要度-時間分割 これはスクエニの資料の方にあった話で、各作業に 重要度: 高/中/低 および かかる時間: 大/中/小 をそれぞれ割り振って3x3のボードに配置する。 手を付けるべき作業によい感じに優先順位を割り振るときに便利そう。
スケジューリング 各作業に対して締め切りを(最速見積もりと最遅見積もりの2点見積もりがいいらしい)割り振る。 その上で、要素成果物Yに対して作業X1..Xnが必要な場合、Yにかかる見積もり時間はX1..Xnの依存グラフのpathの中でもっとも合計時間が長くなるpath(クリティカルパスという)の合計になる。
当たり前ではあるけど、クリティカルパスを常に意識することは重要で、そこが一番足をひっぱるので納期に一番影響しやすい。
それと作業や成果物を諦めるという選択を行う場合、それに依存している全ての作業を切り捨てられるので全体にかかる時間もかなり変わってくるはず。 個人でやるなら人間の数は変えられないので成果物を捨てる判断が割と必要になる気がする(最初のプロジェクトが夢見がちなだけ説)
個人趣味プロジェクト運用論 PMを学びたいと思ったのは自分一人でプロジェクトを回す時にマネジメント能力足りなくておじゃんになるのが多いからだったのだけど、 まぁ世の中のPM論はほぼチームかつ仕事でやること前提なのでそのままでは使えないってことも結構ある。
ので自分が趣味プロジェクトでPM真面目にやるならこうしたい的な話
締め切りは時刻でなく時間 本でもたいていのtodo管理ソフト的なのでも大体何時何分が締め切りってなってることが多いんだけどこれはリアル生活に影響を与えすぎるので 時間で(何時間、みたいな)見積もりを立てるべきだと思う。
その上で日何時間、週何時間作業して概ね納期はいつ、というのを考えるべき。これは多分PMではなくライフマネジメント的なところ。
WBS &amp; ガントチャート WBSなんて分かればいいので構造化文書なら何でも(markdownかorgあたり)いいってなるが、その後ガントチャートに起こすことを考えるとちょっと考えたほうがいい。 ガントチャートでは締め切り(2点見積もり)を設定した上でそれを時期順に並べ、依存関係が簡単に分かるように図示するという作業が必要になるので結構難しい。
依存関係は単に枝分かれならともかく合流(作業XとYが終わって初めてZに取り掛かれる、みたいなやつ)があるので構造化文書でこれを図示するのは厳しい。 個人的にはテキストで依存関係を明示して(各作業の親作業を登録しておいて)dotとかでグラフ化したものを印刷して机に貼っとくとかするのが最強なのでは説がある。
作業の流れを把握するにはグラフ化されたものが欲しいけど、完了報告&amp;修正とか入れるならテキストでどうにかしたいという欲もあり色々大変。
あと上では構造化文書っていったけどredmineみたいなやつでもいい気がする。あれってどうなんだろ、個人で使うにはめんどくさくならないかな。
スケジューリング 自分はよく作業をボトムアップで見積もるけど、その前に「プロジェクトそのものに飽きる」という悲しい問題があり、それを考えると納期は個人趣味プロジェクトでも確かに存在する。 そういう視点が今までなかったのでよくプロジェクトがエターナってたけど、プロジェクトに飽きる前に最低限の完成形までもっていくというのが実は一番大事なのでは説がある。</description>
      </item>
    
      <item>
        <title>GHC拡張一覧を眺める</title>
        <link>https://myuon.github.io/posts/ghc-exts/</link>
        <pubDate>Sat, 13 Jan 2018 00:38:01 +0900</pubDate>
        <guid>https://myuon.github.io/posts/ghc-exts/</guid>
        <description>GHC-8.2.2のGHC拡張を眺めます。
 10. GHC Language Features User&#39;s Guideの該当セクション 7.6.12. Language options 単に一覧が欲しいだけならここの -X から始まるものを見ると良い  上から順に見ていって後から関連するものとかを再編します。
GHC拡張一覧  AllowAmbiguousTypes 型変数が全て決定していないものを通すようにする (個人的)非推奨1 Arrows arrow notationを使えるようにする FRPする人なんかは使う ApplicativeDo do-notationがApplicativeに対しても使えるようになる 個人的には嫌い BangPatterns 関数の引数やデータ型のパラメーターをstrictに評価する; Strict拡張で事足りることが多い気がする BinaryLiterals バイナリ表現が使えるようになる( 0b11001001 みたいなやつ); 使ったことない CApiFFI FFI関連; 使ったことない ConstrainedClassMethods 型クラスのメソッドに型クラスが受け取る型変数を含む制約が使えるようにするやつ; これHaskell98だとだめってマジ？(そらそうよ) ConstraintKinds Constraintというカインドが使えるようになる CPP Cプリプロセッサが使えるようになる THの代わりにお手軽マクロとして(大量のinstance宣言とかに)使ってる人をたまにみる DataKinds データ型の宣言をカインドの宣言へ昇格する DefaultSignatures 型クラスのメソッドのデフォルト宣言が書けるようになる; Genericsを使った定義みたいな、汎用的な型に対して定義できるけど具体的な型についてはspecializeした方がいいみたいな場面で使われる DeriveAnyClass defaultで宣言したメソッドのみをもつ型クラス、あるいはminimal definitionがない型クラスのinstanceをderivingで導出できるようにするっぽい 詳細色々ありそう DeriveDataTypeable deriving Data ってかける DeriveFunctor deriving Functor ってかける DeriveFoldable deriving Foldable ってかける DeriveGeneric deriving Generic ってかける DeriveLift deriving Lift ってかける LiftはTHのこれで、値をsyntactic expressionに変換できるようにするやつ DeriveTraversable deriving Traversable ってかける DerivingStrategies derivingって書いた時に適用されるストラテジーが衝突する場合にそれらをexplicitにかけるようにするやつ？ ナニコレ DisambiguateRecordFields \k -&amp;gt; k {hoge = x} におけるkのような、推論可能だが曖昧なレコード名を許す EmptyCase case x of {} ってかける Void型を扱う時なんかに使える EmptyDataDecls data Empty のようなコンストラクタを持たない型の宣言を許す ExistentialQuantification exist型が使えるようになる 非推奨とまでは言わないけど使いどころはよく考えたほうがいい ExplicitForall 型宣言のimplicitな全称量化をexplicitにかけるようにする id : forall a.</description>
      </item>
    
      <item>
        <title>V.S. Hask圏</title>
        <link>https://myuon.github.io/posts/versus-hask-category/</link>
        <pubDate>Fri, 05 Jan 2018 22:52:56 +0900</pubDate>
        <guid>https://myuon.github.io/posts/versus-hask-category/</guid>
        <description>Hask圏 Haskellをラムダ計算とみなした時のsyntactic categoryをHask圏というのがよく言われる定義である(と思う)。 Haskellのtypeをobject, hom(A,B) をjudgement x:A |- M:B 全体(を適当な同値関係で割ったもの)とみなして圏を作る(このときしばしばjudgementとこのjudgementから作ったfunction λx.M を区別しない)。
さて基本的な結果として次のことが知られている。
 Hask#Is Hask even a category? Hask is not a category  というわけでHask圏は圏にならないのでそのようなものは存在しない。
Why not? これはundefinedというヤバイ元の存在とcall-by-needの悪魔的評価規則が合わさりこのような現象が生み出される。 主にこの2つが悪さをしているので、この辺をどうにかできればHask categoryが作れる可能性がある。
undefinedを抜く undefinedは「評価ができない(プログラムが正しい値を返さない)」ことを表す元で、普通は(多分)domainのbottomに対応させ、無限ループするプログラムの解釈なんかに使う。 undefinedを抜くためにはプログラムが常に停止して値を返す必要があるので無限ループができないようにする必要がある。
とまぁ言うのは簡単でfixpointを抜けばいいだけなんだけどfixpointもないcalculusがプログラミング言語を名乗るのは片腹痛いのでこれはちょっとナシかなという気持ちになったりする。
call-by-needを捨てる call-by-needを捨てて、call-by-valueとかcall-by-nameとかそういうやつに行くというのも1つだと思う。 GHCのStrict拡張を入れてライブラリもStrict付けて全てビルドしなおせばそれはもうcall-by-valueになる(よね？)はずだったり、まぁcall-by-nameもcall-by-needみたいなもんやろという乱暴な考え方によりcall-by-needを捨てるのは現実的な案だと個人的には思う。
しかしcall-by-needではないHaskellはそれはもうHaskellなんですか(反語)ということもあるのでアイデンティティを捨てる勇気が必要かもしれない。
ここからポエム いずれにせよHaskellという純粋関数型プログラミング言語でHask圏を考えるというのは無理があるということが分かるのだけれど、じゃあHask圏についてcomputer science的に意味がないかというと個人的にはそんなことはないと言いたかった。
個人的に、CSとは「計算機で観測可能な現象に説明をつける」学問であると思うので、実際にHaskellという言語で観測可能な現象について圏論で説明をつけようとする営み自体が否定されることはないと思う。 計算機が発明されて間もないからなのか人類が遅れてるのかはわからないけれど今は計算機の説明を付けるために用意した圏論的なモデルが上手くモデルとして機能していない(モデルが現象の構造を反映する力が弱い)のかもしれないけれど、とりあえず数学的にわかりやすいモデルを取ってきていくつかの技術的な難しさ(categoryにならないとかね)を無視した上で似たような現象をシミュレーション出来ないかを調べている段階だと思えばいいんじゃないかなと。
実際にHaskellに限らず色々なプログラミング言語で観測可能な現象について圏論の方からそれっぽいモデルを提供するぜ的研究はあちこちで見られるので、call-by-needとかにも上手い説明を付けられる直観的で構成が大変じゃないモデルを誰か思いついてくれればよいのだけど。
data &amp; codata HaskellのListがListかつColistであるというのは有名な話だけれど、こういうdatatypeかつcodatatypeがとれるような圏を考えるきっかけは(歴史的なことには私は詳しくないのだけれど)こういうプログラミング言語からの現象が先にあったのかな？と想像してる。 ちなみにこのようなcategoryはalgebraically boundedと呼ばれたりします。
enrichmentの隠蔽 関係ないのだけどHask categoryで圏論やろうとするとenrichmentが色々効いてきて困る、みたいな話をよく聞くし自分もそう思うのだけれど、実はenrichmentは結構避けられる(隠蔽できる)のかもと書いていてちょっと思った。
例えばFunctorのfmap methodは fmap: (Functor F) =&amp;gt; (A -&amp;gt; B) -&amp;gt; FA -&amp;gt; FB という形で書かれる。 これはHaskからHask(の適当なsubcategory)へのfunctorのfmapの型になっているが、圏論的には実際は次のような形をしているはずである: fmap: Hask(A,B) -&amp;gt; Hask(FA,FB) .</description>
      </item>
    
      <item>
        <title>2017年振り返り</title>
        <link>https://myuon.github.io/posts/end-of-2017/</link>
        <pubDate>Sun, 31 Dec 2017 20:24:14 +0900</pubDate>
        <guid>https://myuon.github.io/posts/end-of-2017/</guid>
        <description>2017年が終わりそうなので(去年の記事)。
アウトプット プログラミング&amp;定理証明 github見たら意外と色々やってた。 古い順に
 DOTO: todoリストをアレするwebアプリ。これは就活用に作ったような気がする。TypescriptとReactを使ってやっぱクライアントサイドはつらいって思った記憶。今ならElmとかで作ると思う。 CatQ: Coqによる圏論の形式化。Setoidベースでやったけど、圏論側で仮定したくなる公理の妥当性がCoqの上でも妥当なのかとかが無限に気になりやっぱ真面目にやるなら依存型使うのはダメだなと悟って放棄。 dan: やったことリストを登録してgithubの草みたいに表示したりするやつ。最近使ってない bwitterkuchen: CUI Twitterクライアント。nyantreamを作ることにしたのでメンテはしてないけどしばらく使ってた。 avix: AviUtlという動画編集ソフトのexoファイルを生成するためのHaskellライブラリ。動画編集のときに使おうと思って作ってから一度も使ってない。 sdlight/widx: sdlightはSDLのラッパーライブラリ(ゲームを作ろうとしてついでに作った)。widxはsdlightからwidgetだけを切り離してインターフェイスだけ提供するライブラリ、だったけどBackpackのバグが直らないので開発ができない状態になってる。 nott: Type Theoryに関するまとめノート的なものを置くところ(プログラミング関係ない)。今のバタバタが終わったらまた再開したい。 typed: 型付きラムダ計算の実装(TaPLみながら)と定理証明を雑に投げ込む場所。 claire: LKベースのproof assistant。今年の一人アドベントカレンダーでやったやつ。 myuon.github.io: このブログ。今年入ってからはてなブログからgithub pagesでホスティングすることにし、今はhugoを使うのに落ち着いてる。 nyantream: CUIストリームクライアント(絶賛開発中)。時報/Twitter/Gmail/Slackに対応。GUI版も作りたい。  あと開発中のゲーム(最近開発してないけど)もあった。sdlight/widxが真面目に動くようになれば再開したいけどどうだろう。
絵 自分の中で二次創作という行為への折り合いが付き、二次創作を行えるようになったおかげか特に10月以降はかなり積極的に絵を描くようになった。 多分今年が一番絵が上手くなった(画力向上よりも魅せ方・道具の使い方的な意味で)1年だった気がする。
あとブログ漁ってたら今年の初めに新しいペンタブを買ったようなのでそのおかげもかなりある。 というか、今までラップトップしか持ってなかったのをデスクトップPCを買うのに合わせて21.5インチモニターを買ったので、画面が広くなるのに伴ってペンタブも大きくしたというのが正しい。 作業スペースが広くなるのは良さしかなかった。
最近は左手デバイス(キーボード)が欲しいお年ごろ。
動画編集 去年は色々やってたんだけど今年はあんまりやってない。 (AviUtlはwineでほぼ全機能が動くのに)ボイスロイドがwindowsでしか動かないせいで、動画編集とボイスロイドの録音が別PCでしないといけないのが結構つらいなになってきた。
windowsライセンス欲しい、買ってデスクトップPCの方に入れたい。
ブログ Github Pagesでブログをホスティングすることにしたので、emacsでブログがかけるようになり(今もorg-modeでかいてる)、少なくとも新しく記事を書くときの心理的障壁はだいぶ下がった。
そもそもブログ自体もうちょっと色々手を入れないと不便なところがあるのだけど、まぁemacsでほいほいかける環境は整えたので、頑張って書いていきたいなと思った。
一人アドベントカレンダーの時に確かにめっちゃ書いたけど、それ以外だとあんまり記事更新できてないので2018年はブログでアウトプットするのは積極的にやっていきたい。
生活的なこと 学生生活 割とずっと研究してた。結果が出ないつらさを知ったりした。
数学の研究は精神の健康に悪い。マジで悪い。
デスクトップPCを買った 自作PC組んだよ2017
快適of快適になった。せっかくグラボ積んだのに(といっても大したアレじゃないけど)linux機なこととそもそも自分があんまりゲームやる人種じゃないせいで全然役に立ってないのがちょっともったいない感。
でも動画編集するときのエンコードは前に比べたら爆速になったのでそれはいいところ。
コンテンツ消費 今年も去年に増してコンテンツにお金を投じたりした気がする。 何より今年の始めにデレステ初めて、課金もしたし1年間ほぼ途切れず続けてるのでここまで1つのコンテンツで長く遊んでいるのは中々珍しいなと思ったりしながら今日も遊んでた。 音ゲー楽しいなと思ったけどアーケードに手を出す勇気はない。
プロジェクトマネジメント 結局本を1冊読んだだけなのだけれどプロジェクトマネジメントの勉強をした。 去年のまとめで、スケジュール管理の重要さを自覚した、とか方法論を身に着けたい、みたいなことが書いてあるけど、ちょうどそういうマネジメント的なことがずっと気になっていたのでいっちょ本でも読むかで本を読んでみたりした。
ただし個人の趣味的活動に企業のお仕事的プロジェクトマネジメントを持ち込んでもあまり上手く行かなそうなので、まだ何も活かせてはない。
この辺はもっと色々調べたり考えたりした上で2018年はマネジメントぢからをもっと磨いていきたい。
進路 就活は今年の6月くらいに終わった気がする(これ)。 なので来年4月からは就職して働き始めることになりそう。</description>
      </item>
    
      <item>
        <title>一人CSアドベントカレンダー・最終回</title>
        <link>https://myuon.github.io/posts/2017-csadv-finish/</link>
        <pubDate>Mon, 25 Dec 2017 00:11:02 +0900</pubDate>
        <guid>https://myuon.github.io/posts/2017-csadv-finish/</guid>
        <description>これは一人Computer Scienceアドベントカレンダー 25日目の記事です。
くぅ疲 くぅ〜疲れましたw これにて完結です！
実は、一人アドベントカレンダーを一度くらいやってみたいなと思ったのが始まりでした
本当は話のネタなかったのですが←
ご厚意を無駄にするわけには行かないので自分の中の流行りのネタで挑んでみた所存ですw
以下、各テーマ達のみんなへのメッセジをどぞ(ここだけ原作無視)
 Isabelle基礎編(チュートリアル): 初心者に伝わる内容になってたらいいですね prog-prove読んでたら完全に知らないことが書いてあったりしたのでみなさん読みましょうね Isabelle実践編(IMP): IMPはネタとしては面白いんだけどbig-stepのdeterministicくらいだと内容的には面白みにかけるなという感想 Isabelle応用編(ラムダ計算): SNまで示せたらドヤ顔できたんだけどね(CRも割としんどいけど) Haskell小ネタ: 本当に小ネタだった Isabelle編が当初の予定より長引いたせいで日数的には全然必要なかった Proof Assistant理論編: まとまりのない文章になった感すごい(いつものことや) Proof Assistant実践編: 実装はまぁ別にそんな面白いものでもないなって解説書いてて思った  感想 さて完走した感想(爆笑)ですが、まぁ事前に準備しとくのは大事だねと思いました。 今回はIsabelleの途中までは記事かきためてましたが、結局最後は前日の23時から描き始めるみたいなのが普通だったので書き溜めは大事だなみたいな。
それでも1日も落とさなかった(常に当日0時半までには投稿してた気がする)のはめっちゃ偉いと思います。
あと今年のAdCにもいくつかお誘いを頂いていたんですがまぁこっちがあったのとこっちの記事はシリーズものばかりだったので登録は見送りました。
来年は……ネタがあれば何か書きたいなと思います。一人アドベントカレンダーはしばらく大丈夫です。
おわりに こんな記事読む人いるんかってずっと思いながら書いてましたがもし読んでくれる人がいたならありがとうございました。
本当の本当に終わり1
 ってなんで俺くんが！？のところをやろうとしたら精神が持たなかったって言ったら「くぅ疲をやる覚悟が足りない」って言われました。そのとおりだと思います。 [return]   </description>
      </item>
    
      <item>
        <title>Proof Assistantを作る・発展編 その7</title>
        <link>https://myuon.github.io/posts/proof-assistant-impl-7/</link>
        <pubDate>Sun, 24 Dec 2017 00:04:51 +0900</pubDate>
        <guid>https://myuon.github.io/posts/proof-assistant-impl-7/</guid>
        <description>これは一人Computer Scienceアドベントカレンダー 24日目の記事です。
Proof Assistant 「Claire」の実装の説明は前回までで終わったので、よりProof Assistantとして発展させていくには、という話をします。
実装すべき機能など prover さていきなりめちゃくちゃ重い話ですが、今回はproverを実装しませんでしたがこれは是非とも欲しい機能ではあります。
Isabelleでは色々なproverが提供されていますが、First-order logicのproverの実装は色々なやり方が知られているようなので(※やったことないのでよく知らない)実装できるとよさそうです。
unifier 一旦示した定理は、自由変数を全部メタ変数に変えてから環境に追加されます。 この定理を後から使う場合はこのメタ変数に何か適当なものを代入する必要があり、今回のClaireの実装ではこれは全てユーザーが決定する必要がありました。
各変数ごとに代入を行うのではなく適当な論理式を与えるとそれとunifyしたものを返すような感じにしてくれるコマンドを例えば追加すると多分便利です。
あくまで一例ですが、 goal: |- P(a) /\ P(b) ==&amp;gt; P(a) かつ thm: ?X /\ ?Y ==&amp;gt; ?Z のとき、 このゴールを解消する exact thm を use thm; unify; assumption みたいに定義できるとよさそうです。
HOLの実装 大変なだけです。技術的な難しさは特に無いです(IsabelleのHOLとか参考にするといいかも)。
ところで、Claireには組み込みのequalityがないので、equalityはそれ用のpredicateを後から定義して、公理(reflexivitiyとsubst rule)を追加して使うことになります。
それに関連するrefl, substなどのコマンドを定義しておくと便利です。
マクロ記述言語 前回も説明しましたがhintでGHCをインタープリターとして使うのは起動に時間がかかりすぎるので、まともな言語を定義したほうが便利でしょう。
Isabelleとの関連 ここは実装に関わる話ではないのですが、IsabelleとClaireを比較していくつか気がついたことがあるので紹介しておきます。
prop? bool? Isabelleではprop型というのはあまり見ない(存在しますが、チュートリアルを少しやったくらいでは見ないかもしれません)と思います。
IsabelleのpropはClaireのprop型と同じく、メタロジックの基本型です。 しかし一方でHOLにはbool型というのが組み込みの型であり、これが要は「項の型」になります。
前回も説明したと思いますが、型はFormulaとTermと2つにつき、Formulaにはprop型、Termには他の適当な型がつくことになっています。 bool型というのはTermの方につく型なのですね。
さらにHOLではboolをpropに持ち上げるcoercionが定義されていてこれが効いているので、 lemma: True とか書けますが、これは本来は T :: bool =&amp;gt; prop みたいなのがあって T(True) と解釈されています。 ので、Isabelleを書いていると基本の型はboolでしょ、みたいな気持ちになると思いますがメタロジックの論理式の型はpropで、boolはあくまで項につく型だったのです。</description>
      </item>
    
      <item>
        <title>Proof Assistantを作る・マクロ編 その6</title>
        <link>https://myuon.github.io/posts/proof-assistant-impl-6/</link>
        <pubDate>Sat, 23 Dec 2017 00:04:55 +0900</pubDate>
        <guid>https://myuon.github.io/posts/proof-assistant-impl-6/</guid>
        <description>これは一人Computer Scienceアドベントカレンダー 23日目の記事です。
Proof Assistant 「Claire」の実装について説明していきます。
リポジトリはこちら: myuon/claire
今回はClaireのマクロ機能について説明します。
マクロ記述言語 Proof Assistantでは、コマンドが組み込みのものしか使えないと何かと不便なので(特にライブラリで定義されたデータに対する便利コマンドなんかは組み込みようがないので)、コマンドを定義するためのマクロ記述ができるようにするのが普通です。
Coqでは専用の言語としてLtacがあります。IsabelleではSMLが(直接？この辺よく知らないけど実装側からインタープリター呼ぶみたいなことしてるのだろうか)呼べます。
Claireにもそういう機能を乗っけたいわけですが、言語を新たに定義するのは面倒なのでHaskellで書いたものを直接インタープリターを呼ぶことにします。
マクロはCommandを定義するものと、Declを定義するものと(これはまぁ今回の話とはちょっと違うのですが、あったほうが便利なので用意しておきました)あります。
マクロの実装 マクロ自体は、適当な引数を受け取ってCommand, Declの列を返すような関数です。これはClaire言語やその証明の構文木を返しているわけです。
マクロ定義モジュール 定義は適当なHaskellのモジュールとして記述します。 export_command, export_declに定義したマクロを列挙します。
module Commands where import Claire macro :: Env -&amp;gt; Argument -&amp;gt; [Judgement] -&amp;gt; [Command] macro = ... export_command :: [(String, Env -&amp;gt; Argument -&amp;gt; [Judgement] -&amp;gt; [Command])] export_command = [ (&amp;#34;name&amp;#34;, macro) ] declmacro :: [Argument] -&amp;gt; [Decl] declmacro = ... export_decl :: [(String, [Argument] -&amp;gt; [Decl])] export_decl = [ (&amp;#34;name&amp;#34;, declmacro) ] これを使いたいときは、ClaireのファイルにHs_fileを記述します。</description>
      </item>
    
      <item>
        <title>Proof Assistantを作る・実装編 その5</title>
        <link>https://myuon.github.io/posts/proof-assistant-impl-5/</link>
        <pubDate>Fri, 22 Dec 2017 00:02:50 +0900</pubDate>
        <guid>https://myuon.github.io/posts/proof-assistant-impl-5/</guid>
        <description>これは一人Computer Scienceアドベントカレンダー 22日目の記事です。
Proof Assistant 「Claire」の実装について説明していきます。
リポジトリはこちら: myuon/claire
機能まででproofcheckerのコア機能については説明しました。 今日は雑にtype systemの話をして、Claireを実際に動かして証明を書いてみます。
Environment proofcheckerは環境とよばれる状態をもっていて、ここに証明した定理などを格納しています。 説明していませんでしたが一応紹介しておきます。
Claire.Env
data Env = Env { thms :: M.Map ThmIndex Formula , types :: M.Map Ident Type , proof :: [(Command, String)] , newcommands :: M.Map Ident (Env -&amp;gt; Argument -&amp;gt; [Judgement] -&amp;gt; [Command]) , newdecls :: M.Map Ident ([Argument] -&amp;gt; [Decl]) } 上から順に、「すでに示した定理」「宣言された型つきの項」「直前の定理の証明」「マクロで定義されたコマンド」「マクロで定義された宣言」です。
また、実は定理を示した時に(ThmD節による命題の宣言と証明がcheckされ、環境に定理を追加する時に)定理の自由変数をメタ変数としてgeneralizeする機構が挟んであります(Isabelleでもやっています)。
具体的には、
theorem id: a ==&amp;gt; a proof ... qed -- この証明の直後、Envのthmsには (&amp;#34;id&amp;#34;, Pred &amp;#34;?</description>
      </item>
    
      <item>
        <title>Proof Assistantを作る・実装編 その4</title>
        <link>https://myuon.github.io/posts/proof-assistant-impl-4/</link>
        <pubDate>Thu, 21 Dec 2017 00:20:35 +0900</pubDate>
        <guid>https://myuon.github.io/posts/proof-assistant-impl-4/</guid>
        <description>これは一人Computer Scienceアドベントカレンダー 21日目の記事です。
Proof Assistant 「Claire」の実装について説明していきます。
リポジトリはこちら: myuon/claire
昨日に引き続いてClaireの宣言(Decl)について説明していきます。
Declarations まずはtoplevelMの定義から。
toplevelM :: (Monad m, MonadIO m) =&amp;gt; Coroutine DeclSuspender (StateT Env m) () toplevelM = forever $ do let typecheck fml u k = do { env &amp;lt;- lift get; utyp &amp;lt;- liftIO $ try $ infer env fml; case utyp of Left err -&amp;gt; suspend $ DeclError &amp;#34;typecheck&amp;#34; (toException $ TypeError fml err) (return ()) Right typ | u == typ -&amp;gt; k Right typ -&amp;gt; suspend $ DeclError &amp;#34;typecheck&amp;#34; (toException $ TypeError fml (toException $ UnificationFailed u typ)) (return ()) } decl &amp;lt;- suspend (DeclAwait return) env &amp;lt;- lift get case decl of ここに実装を書く Claireは実は(貧弱ながら)型システムを備えていて、型チェックを一応行います。 とりあえずそれは今はおいておいて、toplevelMはDeclを受け取って実行するのを繰り返すだけの単純なステートマシンです。</description>
      </item>
    
      <item>
        <title>Proof Assistantを作る・実装編 その3</title>
        <link>https://myuon.github.io/posts/proof-assistant-impl-3/</link>
        <pubDate>Wed, 20 Dec 2017 00:12:26 +0900</pubDate>
        <guid>https://myuon.github.io/posts/proof-assistant-impl-3/</guid>
        <description>これは一人Computer Scienceアドベントカレンダー 20日目の記事です。
Proof Assistant 「Claire」の実装について説明していきます。
リポジトリはこちら: myuon/claire
Proofchecker state machine さてClaireのproofcheckerを作っていきます。
前回にもちょこっと話しましたが、proofcheckerをステートマシンとして捉えます。 これは、インタラクティブシェルを実装しなければいけない関係で、proofcheckerを1ステップずつ(証明ファイル1行ずつ)進むという処理をさせたいからです。
proof state 初めに仕様を固めます。
 (state:toplevel) Declを読む; Theoremが来たらstate:commandに移行; 全ての入力を消費するか途中でエラーになったら停止する (state:command) Comを読む; 途中で失敗したらエラーを吐いてstate:toplevelに戻る  注意が必要なのは、state:commandでエラーが出たら、state:toplevelに戻ってエラーが出るところです。 このエラーというのはcheckerを走らせるときは普通のなんでもよいですが、インタラクティブシェルの場合はユーザーにエラー内容を表示しつつ再入力を促す必要があるのであとでcatchする必要があることも念頭に置いておきます。
Coroutine monad さてこういうステートマシンを作りたいときはどうするのがいいでしょうか？ 察しの良い方ならわかるとおりこのアドベントカレンダー14日目の記事 Coroutineモナドとステートマシン でも説明したとおり、Coroutine monadを使います1。
Claire.Checker
Command Machine Suspender 簡単な方から行きます。
data ComSuspender y = ComAwait (Command -&amp;gt; y) | CommandError Ident SomeException y deriving (Functor) commandM :: (Monad m, MonadIO m) =&amp;gt; Env -&amp;gt; Coroutine ComSuspender (StateT [Judgement] m) () commandM = .</description>
      </item>
    
      <item>
        <title>Proof Assistantを作る・実装編 その2</title>
        <link>https://myuon.github.io/posts/proof-assistant-impl-2/</link>
        <pubDate>Tue, 19 Dec 2017 00:00:24 +0900</pubDate>
        <guid>https://myuon.github.io/posts/proof-assistant-impl-2/</guid>
        <description>これは一人Computer Scienceアドベントカレンダー 19日目の記事です。
Proof Assistant 「Claire」の実装について説明していきます。
リポジトリはこちら: myuon/claire
LK proofchecker ルールの適用 LKのproofcheckerを作ります。これは、LKのルールの列を受け取って、それを現在のJudgementに適用した結果を返すような関数です。
例として次のルールを考えます。
Γ,A |- Δ ----------- (AndL1) Γ,A∧B |- Δ このようなルールは下から上に向かって適用します。ので、 Γ,A∧B |- Δ のJudgementを Γ,A |- Δ に変換します。
LKのルールはほとんどintro ruleなのでルールの名前を指定するだけでいいのですが、例えば次のルールCutは新たな(ゴールには出現しない)論理式Aを導入するので、これもルールに合わせて指定する必要があります。
Γ |- Δ,A A,Γ |- Δ -------------------- (Cut) Γ |- Δ このようなことを鑑みて、前回も説明したとおりLKのRule型は次のような定義にしていました。
data Rule = I | Cut Formula -- CutはFormulaを引数に取る ... チェッカー Claire.Checker
newGoal :: Formula -&amp;gt; [Judgement] newGoal fml = [Judgement [] (return fml)] judge :: [Rule] -&amp;gt; [Judgement] -&amp;gt; Either (Rule, [Judgement]) [Judgement] judge rs js = foldl (\m r -&amp;gt; m &amp;gt;&amp;gt;= go r) (Right js) rs where go I (Judgement assms props : js) | length assms == 1 &amp;amp;&amp;amp; assms == props = Right js go (Cut fml) (Judgement assms props : js) = Right $ Judgement assms (fml:props) : Judgement (fml:assms) props : js go AndL1 (Judgement ((fa :/\: fb):assms) props : js) = Right $ Judgement (fa:assms) props : js go AndL2 (Judgement ((fa :/\: fb):assms) props : js) = Right $ Judgement (fb:assms) props : js go AndR (Judgement assms ((fa :/\: fb):props) : js) = Right $ Judgement assms (fa:props) : Judgement assms (fb:props) : js go OrL (Judgement ((fa :\/: fb):assms) props : js) = Right $ Judgement (fa:assms) props : Judgement (fb:assms) props : js go OrR1 (Judgement assms ((fa :\/: fb):props) : js) = Right $ Judgement assms (fa:props) : js go OrR2 (Judgement assms ((fa :\/: fb):props) : js) = Right $ Judgement assms (fb:props) : js go ImpL (Judgement ((fa :==&amp;gt;: fb):assms) props : js) = Right $ Judgement assms (fa:props) : Judgement (fb:assms) props : js go ImpR (Judgement assms ((fa :==&amp;gt;: fb):props) : js) = Right $ Judgement (fa:assms) (fb:props) : js go BottomL (Judgement (Bottom:assms) props : js) = Right js go TopR (Judgement assms (Top:props) : js) = Right js go (ForallL t) (Judgement (Forall x fml:assms) props : js) = Right $ Judgement (substTerm x t fml:assms) props : js go (ForallR y) (Judgement assms (Forall x fml:props) : js) = Right $ Judgement assms (substTerm x (Var y) fml:props) : js go (ExistL y) (Judgement (Exist x fml:assms) props : js) = Right $ Judgement (substTerm x (Var y) fml:assms) props : js go (ExistR t) (Judgement assms (Exist x fml:props) : js) = Right $ Judgement assms (substTerm x t fml:props) : js go WL (Judgement (_:assms) props : js) = Right $ Judgement assms props : js go WR (Judgement assms (_:props) : js) = Right $ Judgement assms props : js go CL (Judgement (fml:assms) props : js) = Right $ Judgement (fml:fml:assms) props : js go CR (Judgement assms (fml:props) : js) = Right $ Judgement assms (fml:fml:props) : js go (PL k) (Judgement assms props : js) | k &amp;lt; length assms = Right $ Judgement (assms !</description>
      </item>
    
      <item>
        <title>Proof Assistantを作る・実装編 その1</title>
        <link>https://myuon.github.io/posts/proof-assistant-impl-1/</link>
        <pubDate>Mon, 18 Dec 2017 00:01:47 +0900</pubDate>
        <guid>https://myuon.github.io/posts/proof-assistant-impl-1/</guid>
        <description>これは一人Computer Scienceアドベントカレンダー 18日目の記事です。
Proof Assistant 「Claire」の実装について説明していきます。
リポジトリはこちら: myuon/claire
Syntax: FOL, LK, Claire 初めにSyntaxの定義をしてからパーサーを用意します。 これがないと何も出来ないので。
FOL Claire.Syntax.FOL
data Term = Var Ident | Abs [Ident] Term | App Term [Term] deriving (Eq, Show) data Formula = Pred Ident [Term] | Top | Bottom | Formula :/\: Formula | Formula :\/: Formula | Formula :==&amp;gt;: Formula | Forall Ident Formula | Exist Ident Formula deriving (Eq, Show) それぞれfirst-order logicの項と論理式の定義です。
項は変数記号であるか関数記号に項を適用したもの、なのですがどうせ関数への代入操作とかするときにラムダ抽象みたいなのが必要になるので最初から割り切ってラムダ計算にしています。 論理式は命題記号に項を適用したもの、あるいはいくつかの論理結合子からなります。
さていきなり大切な話をしますが、これを見てもらうと分かる通りFormulaの方は定義がすでに決まっていて、後から新たな命題結合子を定義することはできません。 例えばiffの記号を fml1 :&amp;lt;==&amp;gt;: fml2 = (fml1 :==&amp;gt;: fml2) :/\: (fml2 :==&amp;gt;: fml1) と定義したいところですがそれは上の定義だと出来ません。 ~::~ をエイリアスとして定め、ユーザーがこの記号を入力したら全て本来の定義を展開したものに差し替えるみたいな方法もありですが、それだとやはり不便なこともあります。</description>
      </item>
    
      <item>
        <title>Proof Assistantを作る・理論編 その2</title>
        <link>https://myuon.github.io/posts/proof-assistant-theory-2/</link>
        <pubDate>Sun, 17 Dec 2017 00:17:12 +0900</pubDate>
        <guid>https://myuon.github.io/posts/proof-assistant-theory-2/</guid>
        <description>これは一人Computer Scienceアドベントカレンダー 17日目の記事です。
昨日に引き続き、Proof Assistantを作る話をしていきます。
今日は実際にこの後作っていくProof Assistant固有の話をしていきます。
Claire言語とその設計 唐突ですがこれから作るProof Assistantを「Claire1」と呼ぶことにします。
リポジトリ: myuon/claire
Claireは実際には複数の言語の組み合わせでできています:
 FOL: Pure logicとしてはfirst-order logicを採用します。 LK: Proof SystemとしてはLK(Sequent Calculus)を採用します Claire: Proof Assistant Claireの証明記述用の言語の名前です コマンド記述言語(コマンド定義マクロ): コマンド記述言語はコマンド名からLKの規則の列を生成するものです。今回はHaskellで記述できるようにします。 HOLライブラリ: Isabelleと同じく、HOLをライブラリとして実装することが出来ます。することができるというだけでかなり大変なのでしませんが。  LKについて Proof Systemとして、Sequent Calculus LKを採用します。定義はwikipediaのページでも見るといいんじゃないでしょうか。
The system LK - Wikipedia
今回LKを採用した理由として、natural deductionに比べると推論規則を適用した時のゴールの変形の選択肢が少ない(規則を適用する時に必要な情報が少ない)ことがあります。 というか、natural deductionは命題変数の数を減らすelimination ruleを多く含みますがelimination ruleはゴールに対して適用する、つまり下から上に読むと新たな変数を導入することになるので曖昧さが出やすいです。
それに比べるとSequent Calculusは(仮定とゴールを上手く用意することで)ruleが基本的にintro ruleばかりなので曖昧さが出にくいので、コマンドを適用して証明を書くのには便利かなと思って採用しました。
あとLK触れたことないのでちょっと触ってみたかった的なアレもあります(こっちの理由のほうが大きいかもしれない)。
LKについてそこまで説明をするつもりはありませんが、次のようなことをおさえておいてください。
 judgementは Pn,P(n-1)..P1 |- Q1,Q2..Qm の形(PやQはfirst-order logicの論理式)。左側を仮定、右側を命題(propositions)という。 仮定は「全てがなりたつ」 命題は「いずれかが成り立つ」の意味になる 仮定は右から、命題は左から順番に読んでいく(まぁこれは記法の問題なのでどちらでもよいが) 論理結合子に対する規則は、それが左辺に現れる場合と右辺に現れる場合とあることに注意。例えばAndの規則はAndL1, AndL2, AndRの3つ。 LKは古典的(背理法が使える)である。(注:命題の数を常に1つだけに制限すると直観主義になる) (例) AndLの規則により B |- Qs ==&amp;gt; And(A,B) |- Qs がわかる。これは、「Bの下でQ1.</description>
      </item>
    
      <item>
        <title>Proof Assistantを作る・理論編 その1</title>
        <link>https://myuon.github.io/posts/proof-assistant-theory-1/</link>
        <pubDate>Sat, 16 Dec 2017 00:04:42 +0900</pubDate>
        <guid>https://myuon.github.io/posts/proof-assistant-theory-1/</guid>
        <description>これは一人Computer Scienceアドベントカレンダー 16日目の記事です。
さてCSアドベントカレンダーも後半戦ということで、Proof Assistantを作ります。
Proof Assistantを作ったことがある人は少ないと思うのでまずどういう風に言語を設計していくかという話をしてから、今回実際に作る言語の説明に入ります。
Proof Assistantとは Proof Assistantは大体次のいずれかの方式をとるものが多いです。
 適当なロジックの適当な公理系の証明を解釈するもの: 数学がやっている証明の形式化をそのままやるやり方です。IsabelleやHOLなど。 Curry-Howard対応を用いるもの: 要は型付きラムダ計算を直接実装するやり方です。CoqやAgdaなど。  どっちでも構いませんがどっちを選ぶかによって実装は割と変わってきます。今回はIsabelleと同じく前者の方法をとります。
ところで、Proof Assistant(言語)には大きく分けると次の2種類の言語を持ちます。
 命題記述言語: これは命題を記述する言語というだけでなく、Proof Assistantに組み込まれているロジックそのものを表現するために必要な言語でもあります。 証明記述言語: 証明を記述するためには専用の言語が必要な場合があります。ラムダ計算を直接実装する場合はラムダ項そのものでも別に構いません(Agdaみたいな)が、証明を記述するためにメタ言語を載せている言語も(Coqとか)あります。あるいはproverを実装するならこの言語から呼び出せるようにします。  Isabelleの場合は、前者がPure logicと呼ばれるロジックで、後者はIsarが該当します。
証明の記述について 証明の記述にはいくつかのやり方があります。ラムダ計算を実装する場合はラムダ項を直接書くようにするのが楽ですが、公理系を実装する場合は真面目に作る必要があります。
雰囲気としては、次のような操作で記述できるとよさそうです。 (インタラクティブに書けるならこんな感じという気持ちですが、普通にファイルに記述してチェッカーを走らせる場合も裏ではこういう感じになっています)
 Proof Assistantを起動する 証明したい命題を入力 (例: a -&amp;gt; a) 現在のゴールが a -&amp;gt; a になる 証明を記述する (例: \x. x や apply Identity のように入力する) 証明が完了する  証明を書くにはゴールをユーザーに表示し続ける仕組みはあったほうがよくて、ただまぁそれを真面目にやろうとするとエディタ・プラグインの開発が必要になるのでインタラクティブシェルみたいなものを作るのがとりあえず無難かなという気がします。
メタロジックについて proof assistantに備わっている命題記述言語はIsabelleでいうところのPure logicと言いましたが、これは組み込みのロジックなだけでユーザーが証明を書くのにこの言語しか選択肢がないわけではありません。ロジックとは記号からなる項とその上の規則がいくつかあれば実装可能なので、組み込みのロジックを用いて新たに(ライブラリとして)別のロジックを実装することが出来ます。 このようにして組み込みのロジックで新たに別のロジックを実装するのは、ちょうどIsabelleもPure logicの上でHOLやFOLをライブラリとして提供しているのと同じです。このようにする利点として、組み込みのロジックはcheckerやproverにとって都合の良いロジックを選び、ユーザーに記述させるロジックはより読み書きしやすいものを選ぶ、みたいなことが出来ます。
ここでライブラリで定義されているロジックに対して組み込みのロジックをメタロジックと呼ぶことにします。
当然ながらメタロジックが弱すぎると欲しいロジックが定義できなかったりするのでそのへんは注意が必要です。まともに数学をしたいならfirst-order logicくらいは欲しくなるという気がします(がもっと弱くしてもいいのかもしれません、ロジック詳しくないのでよくわかりません)。
証明記述マクロ 公理系を用いた証明は、公理・推論規則をゴールに適用していくことで記述するわけです。しかしそれだけでは通常不便なので色々便利なコマンドを作ったりproverを作ったりすることになると思います。
ところでこういう証明用のコマンドを実装するためにマクロとかそういうものが欲しくなると思います。 ここではコマンドは推論規則の列を、つまり証明を生成するマクロとして登録しておくことにします。例えばCoqではLtacという専用のマクロ記述言語(と呼んでいいのかな？普通に証明生成言語と呼ぶべきかもしれません)がありますが、IsabelleではSMLで内部実装のAPIを呼び出してこういう感じのことをしています。</description>
      </item>
    
      <item>
        <title>Haskellプロジェクトを始めるにあたって</title>
        <link>https://myuon.github.io/posts/haskell-project-setup/</link>
        <pubDate>Fri, 15 Dec 2017 00:04:21 +0900</pubDate>
        <guid>https://myuon.github.io/posts/haskell-project-setup/</guid>
        <description>これは一人Computer Scienceアドベントカレンダー 15日目の記事です。
Computer Science何も関係ないけど大丈夫か？(まぁ一応Haskellはテーマの1つであったというアレはあるけど)
今回はHaskellで開発を始める時にいつもやってるセットアップの作業とかの説明をします。 どうも、Haskellerによるstackみたいな周辺ツールの情報の発信が足りてないんじゃないかみたいな噂が流れてきたのでじゃあまぁなんか記事にするかという流れです。
ところでstackの説明はググれば日本語の記事がそれなりにヒットするようになったと思うのでここではあんまり説明しません。
開発環境構築 このセクションは初回のみです。
Haskellのインストール stackはプロジェクトを管理するツールっていうのかな？まぁビルドツールになったりパッケージマネージャーになったりghcを管理するのに使ったりなんかまぁそういうツールです(なんて言えばいいんだろう)。
linux系なら公式ドキュメントを見ながら次のようにするといいと思います。
$ curl -sSL https://get.haskellstack.org/ | sh # stackのinstall  $ stack setup # GHC(コンパイラ)を入れる stackを入れてから stack setup でコンパイラが入るのでのんびり待ちます。 ~/.local/bin/ にパスを通しておきます。
エディタ  emacsの人: intero spacemacsの人: haskell layer IntelliJ IDEAの人: intellij-haskell  を使いましょう。その他のエディタは知らない(emacs/intellijのプラグインが特に優秀みたいなので可能ならどっちかを使うのがいいんじゃないでしょうか)。
プロジェクトセットアップ stack new [2017/12/16追記]
どうやらstackのデフォルトテンプレートであるnew-templateがいつの間にやらhpackを使うように変わったようです。なので、以下のsimple-hpackは不要で普通に stack new [プロジェクトの名前] とすれば同じものが得られます1。
[/追記]
さてHaskellでプロジェクトを始めます。
$ stack new [プロジェクトの名前] simple-hpack simple-hpackというのはテンプレートの名前です。ここではhpackというツールを使っています(私が普段から使っているので)。
(以下昔話なので読まなくてもいいです) さて少しだけ説明をすると、stackという便利ツールが登場する前はみんなcabalというビルドツールを使っていました。cabalはcabalファイルの情報を読み込んでビルドをするのですが、cabalファイルはちょっと面倒な部分があったのでこれをもっと簡単に書けるようにするためにhpackというツールが最近登場しました。 hpackはpackage.yamlをcabalファイルに変換するツールですが、今はstackが公式にhpackをサポートしたので、プロジェクトでpackage.yamlに必要な情報を書くとそれがhpackによってcabalファイルに変換されてcabalによるビルドが走るというところまで全てstackが面倒を見てくれます。
正直好みですが個人的にはhpackの方が楽なのでこれを使うためにここではsimple-hpackのテンプレートを指定しています。
また、以下の説明は全てhpackのpackage.yaml前提です。cabalファイルはまた少し違うので対応表で各自調べてください。
configuration stack newが終わると必要なファイル群と stack.</description>
      </item>
    
      <item>
        <title>Coroutineモナドとステートマシン</title>
        <link>https://myuon.github.io/posts/coroutine-monad-as-state-machine/</link>
        <pubDate>Thu, 14 Dec 2017 00:03:01 +0900</pubDate>
        <guid>https://myuon.github.io/posts/coroutine-monad-as-state-machine/</guid>
        <description>これは一人Computer Scienceアドベントカレンダー 14日目の記事です。
今回は小ネタです。
monad-coroutineというライブラリを使って状態遷移してそうなプログラムを書こうみたいな話をします。
Coroutine-monad example: coroutine 名前の通りmonad-coroutineはコルーチン(つまりプログラムを一旦停止して値を返し、再び停止したところから再開できるような仕組み)を提供します。
サンプルとしては次のような感じ:
countup :: Coroutine (Yield Int) IO () countup = do lift $ print &amp;#34;counting...&amp;#34; yield 1 lift $ print &amp;#34;counting...&amp;#34; yield 2 return () printProduce :: Show x =&amp;gt; Coroutine (Yield x) IO r -&amp;gt; IO r printProduce producer = pogoStick (\(Yield x cont) -&amp;gt; lift (print x) &amp;gt;&amp;gt; cont) producer {- &amp;gt; printProduce countup counting... 1 counting... 2 -} countup内ではyieldという関数が使われていて、 yield :: Monad m =&amp;gt; x -&amp;gt; Coroutine (Yield x) m () なので Coroutine (Yield x) m () ではx型の値をyieldして停止することができる。 pogoStickは Yield x r の挙動を指定して、それを使ってCoroutineを潰すことができる。</description>
      </item>
    
      <item>
        <title>Nominal Isabelleとラムダ計算 その4</title>
        <link>https://myuon.github.io/posts/nominal-lambda-4/</link>
        <pubDate>Wed, 13 Dec 2017 00:04:03 +0900</pubDate>
        <guid>https://myuon.github.io/posts/nominal-lambda-4/</guid>
        <description>これは一人Computer Scienceアドベントカレンダー 13日目の記事です。
さて、前回はChurch-Rosserを示しました。今回は型付きラムダ計算もやっとかないとだめかなと思ったのでsimply-typedのtype soundnessです。 流石にラムダ計算の話題ばっかりで疲れてきたと思いますが今回は1日ですべて終わらせます。
まぁCRに比べればずっと簡単なのでいけるでしょ(適当)
今回解説するコードは以下にあります:
myuon:typed/theory/Simply.thy
Simply-typed nominal_datatype simply = TVar string | TArr simply simply (infixr &amp;#34;→&amp;#34; 90) simply-typedな型はtype variableとfunction typeからなる。 typeの定義自体は特にbinderを含まないが、後に型を含むnominal_inductiveの宣言をしたりする都合上nominal_datatypeにしてある。
valid context さて型付けに必要になるcontext(変数とその型を組にしたもの)は同じ変数を複数含んではいけないという制約があるので、それを表すvalidという述語を定義する。
inductive valid :: &amp;#34;(name × simply) list ⇒ bool&amp;#34; where valid_nil: &amp;#34;valid []&amp;#34; | valid_cons: &amp;#34;⟦ valid Γ; x ♯ Γ ⟧ ⟹ valid ((x,T)#Γ)&amp;#34; equivariance valid lemma elim_valid_cons: &amp;#34;valid ((x,T)#Γ) ⟹ valid Γ ∧ x ♯ Γ&amp;#34; by (cases rule: valid.</description>
      </item>
    
      <item>
        <title>Nominal Isabelleとラムダ計算 その3</title>
        <link>https://myuon.github.io/posts/nominal-lambda-3/</link>
        <pubDate>Tue, 12 Dec 2017 00:05:37 +0900</pubDate>
        <guid>https://myuon.github.io/posts/nominal-lambda-3/</guid>
        <description>これは一人Computer Scienceアドベントカレンダー 12日目の記事です。
前回はCRの証明の途中までやったので続きです。 内容多めですが今回で頑張って終わらせます。
confluenceへ (cont.) coherent lemmas parallel betaのcoherent lemmaを示す。 証明は基本的に場合分けやるだけなので省略するとして、まぁ常識的なことが成り立つよねという補題である。(説明の放棄)
lemma elim_pb_var: &amp;#34;Var x ⇒β N ⟹ N = Var x&amp;#34; lemma elim_pb_abs: assumes &amp;#34;lam [x]. M ⇒β N&amp;#39;&amp;#34; &amp;#34;x ♯ N&amp;#39;&amp;#34; obtains N where &amp;#34;M ⇒β N&amp;#34; &amp;#34;N&amp;#39; = lam [x]. N&amp;#34; lemma elim_pb_app: assumes &amp;#34;M1 $ M2 ⇒β N&amp;#34; obtains N1 N2 where &amp;#34;N = N1 $ N2&amp;#34; &amp;#34;M1 ⇒β N1&amp;#34; &amp;#34;M2 ⇒β N2&amp;#34; | x P P&amp;#39; L where &amp;#34;M1 = lam[x].</description>
      </item>
    
      <item>
        <title>Nominal Isabelleとラムダ計算 その2</title>
        <link>https://myuon.github.io/posts/nominal-lambda-2/</link>
        <pubDate>Mon, 11 Dec 2017 00:13:11 +0900</pubDate>
        <guid>https://myuon.github.io/posts/nominal-lambda-2/</guid>
        <description>これは一人Computer Scienceアドベントカレンダー 11日目の記事です。
前回はNominal Isabelleの説明と証明を少しだけしました。 今回から徐々に証明したいことの内容(ラムダ計算そのもの)の話もしていきます。
equivarianceとnominal_inductive 補題 さて2つの補題を示しておく。
lemma subst_eqvt[eqvt]: fixes π :: &amp;#34;var prm&amp;#34; shows &amp;#34;π∙(t[x ::= s]) = (π∙t)[(π∙x) ::= (π∙s)]&amp;#34; apply (nominal_induct t avoiding: x s rule: strong_induct) apply (simp add: perm_bij) apply (simp) apply (simp add: fresh_bij) done lemma subst_rename: assumes &amp;#34;x ♯ t&amp;#34; shows &amp;#34;([(x,y)]∙t) [x ::= s] = t [y ::= s]&amp;#34; using assms apply (nominal_induct t avoiding: x y s rule: lambda.strong_induct) apply (auto simp add: swap_simps fresh_atm abs_fresh) done subst_eqvtに [eqvt] というattributeがついていることに注目して欲しい。 これはprm(変数の置換)の作用に関する等式につけるattributeで、実際にsubst_eqvtは π∙M = .</description>
      </item>
    
      <item>
        <title>Nominal Isabelleとラムダ計算 その1</title>
        <link>https://myuon.github.io/posts/nominal-lambda-1/</link>
        <pubDate>Sun, 10 Dec 2017 00:13:17 +0900</pubDate>
        <guid>https://myuon.github.io/posts/nominal-lambda-1/</guid>
        <description>これは一人Computer Scienceアドベントカレンダー 10日目の記事です。
前回、4日分に分けてIMPのoperational semanticsの証明の解説をしてみました。 今回はより発展的な話題として、Nominal Isabelleを用いてChurch-Rosser性やSimply-typedのsoundnessなどを示してみようと思います。
定理証明に詳しい人ならもうこれだけでつらさが伝わるかと思うのですが、実際証明はかなり大変なので今回は発展編(応用編)としてこの話題を選んでみました。
今回解説するコードは以下に置いてあります。
myuon/CR.thy
前置き ラムダ計算 この記事をわざわざ読む人はラムダ計算についてはある程度知っている人が多いと思うのですが、簡単に説明をしておきます。
ラムダ計算は計算のモデルとなるべく作られた言語で、「関数を作る・作った関数を呼び出す(関数を適用すること)」の2つの操作を基本とします。 ここでの「計算」とは数を与えたら数を返す、のような、電卓で行われるような最も我々がイメージしやすい計算のことです。ラムダ計算ではこの「計算」を、項を別の項に変換するような操作によって実現します。 これは単に 1+2 という項があったらそれを 3 へと変換する、あるいは f(x)=x+2 という項があるときに、 f(10) を 12 へと変換する、そういう操作を計算と呼びますというだけなので難しいことはありません。
さてラムダ計算の項(何がラムダ計算の項かはまだちゃんと説明していないけど)は通常変数の付け替えを同一視します。具体的には f(x)=x と f(y)=y を区別しないのですが、この同値をα同値と呼びます。
ラムダ計算の定理証明で最も厄介なのはこのα同値性の扱いで、というか定理証明による形式化ではそもそも「同一視」とか「同値関係で割る」みたいな操作を扱うのがめちゃくちゃ苦手です。 これは主に、一般に同一視されているかが計算によって判定可能でないこと1と、同一視された項同士の計算はしばしば(人間は気にしないけど)それらの項の変形の構成に依存するからだと個人的には思っています。
はてさて真面目にラムダ計算の形式化をやると地獄をみますが、そんな時にNominal Isabelleが便利なんですよ〜！っていうのがこの導入です。
Nominal Isabelle Nominal Isabelleは(ラムダ項だけではなく; ラムダ計算みたい題材が最も威力を発揮することは間違いないが)binderを含むデータ型を扱う際に利用すると便利なライブラリである。 binderは [x]. M のような形をしていて、この束縛変数 x の変数名の付け替えを区別しないような項である。
Nominal Isabelleではこの変数の付け替え、「例えば変数 x を y に付け替える」という操作を「置換 (x,y) を作用させる」という操作とみなす、というところからスタートする。 より厳密には次のようなことである: 無限の変数からなる集合 V が与えられている時、 List (V×V) の元を置換と呼ぶ。このとき置換の作用を ∙ でかくことにし、 ((x,y)::xs)∙M := xs∙(Mに出現する自由変数xをyに、yをxに書き換えた項); []∙M := M のようにして定める。</description>
      </item>
    
      <item>
        <title>IsabelleについてのQ&amp;A</title>
        <link>https://myuon.github.io/posts/isabelle-qanda/</link>
        <pubDate>Sat, 09 Dec 2017 00:03:23 +0900</pubDate>
        <guid>https://myuon.github.io/posts/isabelle-qanda/</guid>
        <description>これは一人Computer Scienceアドベントカレンダー 9日目の記事です。
さて、Isabelleの入門編・基礎編が終わったところで、お口直しに(？？)Isabelleで証明していると遭遇するかもしれない疑問に答えたりする記事を用意してみました。
というか、私がIsabelleを学ぶ過程で公式のリファレンス以外に困った時に頼れるものがなかったりして大変苦労したのでせめて後の人のために身についたノウハウは記事に還元していきたいという気持ちからこういうコーナーを挟んでみました。
Syntax関係 矢印がいっぱいあるんだけど何  =&amp;gt; : HOLのfunction type constructor ==&amp;gt; : Pure logicのimplication --&amp;gt; : HOLのimplication  Pure logicってなんですか (この辺の話は後半のところでもやる予定なんですが)Isabelleはライブラリのとは別に組み込みのロジックあって、これがPure logicと呼ばれています。 そもそもIsabelleは本来Pure logic上で証明を行うproof assistantなんですが、このPure logicの上に別のlogicを構成することが出来て、それがHOLやZFCです。
なのでHOLの証明は内部的には全てPure logicの証明図に置き換えてcheckされます。 AgdaやCoqなどの言語ではこういうことはしない(組み込みのものをそのまま使う)ので慣れないと不思議に感じるかもしれません。
依存型とかないんですか ないよ(無慈悲)
知らないキーワード・コマンド・attributeが出てきた/便利なコマンドについて知りたい  isar-ref.pdfのAppendixにquick referenceあるので眺めるとよいかも？  証明関係 Sledgehammerと仲良くなれない これは慣れもありますが、 (1) goalを優しくする (2) 証明の選び方 の2点がポイントです。
まずsledgehammerは優秀とはいえそれでも人間の「自明」とはかなり感覚が違います。 そもそも人間が自明だと思っていてもformalizeにはたくさん補題が必要だったりするので、出来る限りsledgehammerに与える命題は分かりやすく、すぐ示せそうなものだけにしたほうがいいです。
あと、余分な仮定が多いと探索が失敗しやすいです。goalが複雑なときは示したい命題を補題として切り出したりしたほうがいいこともあります。
それと、どうしても上手くいかないときは命題を見直しましょう。「簡単なはずなのにsledgehammerが答えを返さないぞ？」ってときはそもそも間違っている(goalが成り立たない)ことがあります。
次に、探索に成功し証明が複数出た場合、可能ならば簡単で応答の早い証明を選んだほうがいいです。 気をつけるべきはmetisで、これは現実的な時間では終わらない場合があるので避けられるならmetisを含まないものにするか、またはmetisに与えられた補題で先に使えるものは使ってしまいましょう。
例えば、
by (metis lemmaA lemmaB lemmaC) の時に、lemmaAが先に適用されてそれ以後使わないことがはっきりしているなら
apply (rule lemmaA) by (metis lemmaB lemmC) としたほうが応答が早くなります。あるいはapplyの後にもう一度sledehammerをかけてもいいでしょう。
自動証明コマンドって使い分けるもの？ ある程度はね。</description>
      </item>
    
      <item>
        <title>IMPのoperational semantics その4</title>
        <link>https://myuon.github.io/posts/2017csadv-day8/</link>
        <pubDate>Fri, 08 Dec 2017 00:01:48 +0900</pubDate>
        <guid>https://myuon.github.io/posts/2017csadv-day8/</guid>
        <description>これは一人Computer Scienceアドベントカレンダー 8日目の記事です。
前回は、big-stepがdeterministicであることを示した。
9. Small-step long reduction csmallを複数回適用した、ということを表す関係を &amp;lt;_,_&amp;gt; ⟶* &amp;lt;_,_&amp;gt; でかいて、次のように定める。
subsubsection {* small-step long reduction *} inductive csmall_long (&amp;#34;&amp;lt;_,_&amp;gt; ⟶* &amp;lt;_,_&amp;gt;&amp;#34;) where SL_refl: &amp;#34;&amp;lt;c,st&amp;gt; ⟶* &amp;lt;c,st&amp;gt;&amp;#34; | SL_trans1: &amp;#34;⟦ &amp;lt;c,st&amp;gt; ⟶ &amp;lt;c&amp;#39;,st&amp;#39;&amp;gt;; &amp;lt;c&amp;#39;,st&amp;#39;&amp;gt; ⟶* &amp;lt;c&amp;#39;&amp;#39;,st&amp;#39;&amp;#39;&amp;gt; ⟧ ⟹ &amp;lt;c,st&amp;gt; ⟶* &amp;lt;c&amp;#39;&amp;#39;,st&amp;#39;&amp;#39;&amp;gt;&amp;#34; lemma SL_trans: &amp;#34;⟦ &amp;lt;c,st&amp;gt; ⟶* &amp;lt;c&amp;#39;,st&amp;#39;&amp;gt;; &amp;lt;c&amp;#39;,st&amp;#39;&amp;gt; ⟶* &amp;lt;c&amp;#39;&amp;#39;,st&amp;#39;&amp;#39;&amp;gt; ⟧ ⟹ &amp;lt;c,st&amp;gt; ⟶* &amp;lt;c&amp;#39;&amp;#39;,st&amp;#39;&amp;#39;&amp;gt;&amp;#34; apply (induction arbitrary: c&amp;#39;&amp;#39; st&amp;#39;&amp;#39; rule: csmall_long.induct) apply simp apply (blast intro: SL_trans1) done lemma SL_SeqStep: &amp;#34;&amp;lt;c1,st&amp;gt; ⟶* &amp;lt;c1&amp;#39;,st&amp;#39;&amp;gt; ⟹ &amp;lt;c1;;c2,st&amp;gt; ⟶* &amp;lt;c1&amp;#39;;;c2,st&amp;#39;&amp;gt;&amp;#34; apply (induction arbitrary: c2 rule: csmall_long.</description>
      </item>
    
      <item>
        <title>IMPのoperational semantics その3</title>
        <link>https://myuon.github.io/posts/2017csadv-day7/</link>
        <pubDate>Thu, 07 Dec 2017 00:18:10 +0900</pubDate>
        <guid>https://myuon.github.io/posts/2017csadv-day7/</guid>
        <description>これは一人Computer Scienceアドベントカレンダー 7日目の記事です。
前回はcommandとcommandの評価を定義した。
6. Coherent lemmas SKIP subsection {* Coherent lemmas *} lemma coh_B_Skip: assumes &amp;#34;&amp;lt;SKIP,st&amp;gt; ⇓ st&amp;#39;&amp;#34; shows &amp;#34;st = st&amp;#39;&amp;#34; using cbig.cases [OF assms] by auto 始めの補題はSKIPについてで、 &amp;lt;SKIP,st&amp;gt; ⇓ st&#39; ならば st = st&#39; というものである。 直観的には明らかであろうし、証明も場合分けをするだけで済む。
Ass lemma coh_B_Ass: assumes &amp;#34;&amp;lt;x ::= a , st&amp;gt; ⇓ st&amp;#39;&amp;#34; shows &amp;#34;st&amp;#39; = st [x ↦ aeval st a]&amp;#34; using cbig.cases [OF assms] by auto 次は変数への代入。これも簡単なので省略。
Seq lemma coh_B_Seq: assumes &amp;#34;&amp;lt;c1 ;; c2 , st&amp;gt; ⇓ st&amp;#39;&amp;#34; obtains st&amp;#39;&amp;#39; where &amp;#34;&amp;lt;c1 , st&amp;gt; ⇓ st&amp;#39;&amp;#39;&amp;#34; and &amp;#34;&amp;lt;c2 , st&amp;#39;&amp;#39;&amp;gt; ⇓ st&amp;#39;&amp;#34; &amp;lt;c1 ;; c2,st&amp;gt; ⇓ st&#39; ならば、 c1 を実行すると評価が停止し、さらにその後 c2 を実行すると st&#39; の状態になって評価が停止するということが言えるはずである。 上では後々の便利さのために obtains .</description>
      </item>
    
      <item>
        <title>IMPのoperational semantics その2</title>
        <link>https://myuon.github.io/posts/2017csadv-day6/</link>
        <pubDate>Wed, 06 Dec 2017 00:07:53 +0900</pubDate>
        <guid>https://myuon.github.io/posts/2017csadv-day6/</guid>
        <description>これは一人Computer Scienceアドベントカレンダー 6日目の記事です。
前回はaexp/bexpとそのevaluationを定めた。
3. Commands さて次にcommandを定義する。
これはIMPの「命令」や「文」にあたるもので、変数の代入、If文、While文などが用意されている。
section {* Commands *} subsection {* Syntax *} datatype com = CSkip | CAssign id aexp | CSeq com com | CIf bexp com com | CWhile bexp com notation CSkip (&amp;#34;SKIP&amp;#34;) and CAssign (&amp;#34;_ ::= _&amp;#34; [50,50] 90) and CSeq (infixr &amp;#34;;;&amp;#34; 30) and CIf (&amp;#34;IF _ THEN _ ELSE _&amp;#34; 80) and CWhile (&amp;#34;WHILE _ DO _&amp;#34; 90) comを定義した後、notationによって各コンストラクタをよりそれらしいnotationで記述できるようにしている。 このように定義しておくと、例えば以下のような記述ができるようになる。</description>
      </item>
    
      <item>
        <title>IMPのoperational semantics その1</title>
        <link>https://myuon.github.io/posts/2017csadv-day5/</link>
        <pubDate>Tue, 05 Dec 2017 00:02:29 +0900</pubDate>
        <guid>https://myuon.github.io/posts/2017csadv-day5/</guid>
        <description>これは一人Computer Scienceアドベントカレンダー 5日目の記事です。
今回から実際に実践的な証明をしながらIsabelleの解説をしていこうと思います。 そしてこの記事は一人computer scienceアドベントカレンダーなのでCSらしい話題を、ということで、 IMPのoperational semanticsの話でもしようと思います。
IMPについて IMPとはimperative languageの頭文字を取ったもので、natとboolを基本型にもつ簡単な手続き型言語です。 CSの教科書とかでよく見かけるやつです。 IMPの定義をし、そのevaluationを定めます。
ただし、IMPはチューリング完全なので評価は一般には停止しません。つまりプログラムを「評価」して結果を返すような関数は全域関数にはなりません。 このような評価を表す部分関数(関係)を定め、実際にこれがいい感じの性質をもつことを示していきます。
0. States IMPの定義を行う前の準備。IMPは変数を扱うことができるので変数名を処理するための型が必要になるのと、プログラムの実行には実際に各変数の値を記録したもの(環境の一種)が必要になるのでそれらを定義する。
section {* States *} type_synonym id = string type_synonym state = &amp;#34;id ⇒ nat&amp;#34; definition empty :: &amp;#34;state&amp;#34; where &amp;#34;empty _ = 0&amp;#34; no_syntax &amp;#34;_maplet&amp;#34; :: &amp;#34;[&amp;#39;a, &amp;#39;a] ⇒ maplet&amp;#34; (&amp;#34;_ /↦/ _&amp;#34;) fun update :: &amp;#34;state ⇒ id ⇒ nat ⇒ state&amp;#34; (&amp;#34;_[_ ↦ _]&amp;#34; [80,80,80] 80) where &amp;#34;update st x n y = (if x = y then n else st y)&amp;#34; sectionコマンドは証明には影響を与えないが、Sidekickにsectionとして表示されたりLaTeXに出力すると実際に節として扱われたりするもの。chapter, subsectio, subsubsectionなどもある。</description>
      </item>
    
      <item>
        <title>Isabelle/HOLの基本 その3</title>
        <link>https://myuon.github.io/posts/2017csadv-day4/</link>
        <pubDate>Mon, 04 Dec 2017 00:39:09 +0900</pubDate>
        <guid>https://myuon.github.io/posts/2017csadv-day4/</guid>
        <description>これは一人Computer Scienceアドベントカレンダー 4日目の記事です。
テキスト代わりのチュートリアル: prog-prove.pdf
前回はHOLと自動証明についてやりました。 今回やる4章では、Isarという新しい言語(？)について見ていきます。
4. Isar: A Language for Structured Proofs IsabelleはIsarという、structured proofを記述するための言語を別に提供している。 これはapplyを繋げて証明をするのとは違い、構造化された証明をキーワードを組み合わせて記述する、より自然言語による証明に近い記述を可能にする言語である。
Isarのsyntaxのコアは次のようになっている(実際はもっと膨大):
proof = &amp;#39;by&amp;#39; method | &amp;#39;proof&amp;#39; [method] step* &amp;#39;qed&amp;#39; step = &amp;#39;fix&amp;#39; variables | &amp;#39;assume&amp;#39; proposition | [&amp;#39;from&amp;#39; fact+] (&amp;#39;have&amp;#39; | &amp;#39;show&amp;#39;) proposition proof proposition = [name :] &amp;#34;formula&amp;#34; 4.1 Isar by Example 初めにIsarによる証明を見せるので眺めてみよう。
lemma &amp;#34;¬ surj (f :: &amp;#39;a ⇒ &amp;#39;a set)&amp;#34; proof - assume srjf: &amp;#34;surj f&amp;#34; from srjf have fa: &amp;#34;∀A.</description>
      </item>
    
      <item>
        <title>Isabelle/HOLの基本 その2</title>
        <link>https://myuon.github.io/posts/2017csadv-day3/</link>
        <pubDate>Sun, 03 Dec 2017 00:01:48 +0900</pubDate>
        <guid>https://myuon.github.io/posts/2017csadv-day3/</guid>
        <description>これは一人Computer Scienceアドベントカレンダー 3日目の記事です。
テキスト代わりのチュートリアル: prog-prove.pdf
前回は導入と型・関数・証明について学びました。 今回やる3章では、HOLについてと証明を書く際に知っておくと便利なあれこれについてです。
3. Logic and Proof Beyond Equality 3.1 Formulas HOLのformulaの定義は次:
form ::= True | False | term = term | ¬ form | form ∧ form | form ∨ form | form --&amp;gt; form | ∀x. form | ∃x. form termはラムダ式とifとかcaseとかletとかそのへん
3.2 Sets &#39;a のsetを &#39;a set とかく。次のようなnotationが定義されている。
 {} , {e1,e2,e3} e ∈ A , A ⊆ B A ∪ B , A ∩ B , A − B, − A {x | P}  HOLのsetはかなり便利なので積極的に使っていこう。</description>
      </item>
    
      <item>
        <title>Isabelle/HOLの基本 その1</title>
        <link>https://myuon.github.io/posts/2017csadv-day2/</link>
        <pubDate>Sat, 02 Dec 2017 00:00:44 +0900</pubDate>
        <guid>https://myuon.github.io/posts/2017csadv-day2/</guid>
        <description>これは一人Computer Scienceアドベントカレンダー 2日目の記事です。
さて今回よりIsabelle/HOL(HOLはライブラリの名前)の基本の解説をしていきます。 一応極基本的なことを最初に少し説明をしてから、あとは実践形式で実際に証明を書きながら細かい機能などの説明をしていく予定です。 説明に割くページ数とコンテンツの内容と時間的な問題で、定理証明とは何かなどは詳しく話しません。
Isabelle資料 Isabelleのお勉強のための資料をまとめておきます。
 prog-prove.pdf: 公式チュートリアルの一番基本のやつ。入門するならこれだけは 必ず読みましょう 。チュートリアルは他にもトピックごとに色々あるよ！ isar-ref: 主にIsarに関するReference Manualだけど慣れてきたら参照する機会が多いと思う。 caeruiroさんのIsabelle Tutorialシリーズ: 大変貴重な日本語の入門記事。Isabelle-2009を使っているらしいのでもしかしたら古い記述もあるかもしれない。 Concrete Semantics: Isabelleでプログラミング言語のセマンティクスとかやるテキスト。前半はIsabelle入門、後半はCSのテキストみたいな構成。 AFP: Archive of Formal Proofs; Isabelleで証明されたあれこれが投稿されてる証明集みたいなサイト Isabelleの入門の入門: 遥か昔に書いた記事; 何かの役には立つかもしれない  このシリーズの目的 prog-prove.pdfを読んでねでチュートリアルを済ませてしまっても良いのですが、まぁ読んでって言って読んでもらった試しがないので もう少し実際に証明を書きながら解説をすることで、英語が読みたくない人や雰囲気だけ知りたい人にも優しい解説シリーズになればいいかなと思っています。 ひとまずこのIsabelle/HOLの基本シリーズでは上のprog-prove.pdfに沿って話を進めていきます。
内容全部やるなら単なる翻訳になってしまうので適度にぶっ飛ばしつつ要所要所を解説していく感じにします。 定理証明全くしたことないと厳しいこともあるかもぐらいでお願いします。
はじめに. jEditについて 現在Isabelleが公式にサポートしているのはjEditのみです1。 jEditを起動し、エディター画面とアウトプットパネルが表示されていれば問題ありません。アウトプットパネルはなければ Plugins&amp;gt;Isabelle から表示させます。
よく使うパネルを一通り説明しておきます。
 Documentation: Isabelleは豊富な公式ドキュメントが用意されています。 Sidekick: 現在開いているファイルのアウトライン的なものが表示されます。 State: なんやねんこれ Theories: 複数のファイルを開いている場合に、各ファイルのどの辺りまでcheckerが走っているかが一覧で表示されたものです。 Output: ここに情報が表示されます。証明は基本的にこのパネルを見ながら書きます。 Query: 既知の定理の検索などを行います。 Sledgehammer: 現在focusしている証明に対してsledgehammer(後述)を実行することができます。 Symbols: unicode symbolを入力するために使います。  1. Introduction HOLとはhigher-order-logicの略で、Isabelleの標準ライブラリの1つです。 Isabelleでは組み込みのロジックの上に適当な公理系を構成したものをライブラリとして提供しており、HOLやZFC(ZFCはFOLの上のライブラリ)などがあります。
最初はHOLから入るのが良いでしょう。ZFC上で形式化とかしたい人はZFCとか使うのもいいと思います。 また、変数の名前の付け替えなどをいい感じにアレする2Nominalという考え方もあり、それを使ったNominal HOLなんかもサードパーティライブラリとして開発されています。</description>
      </item>
    
      <item>
        <title>一人CSアドベントカレンダー開催のお知らせ</title>
        <link>https://myuon.github.io/posts/2017csadv-day1/</link>
        <pubDate>Fri, 01 Dec 2017 00:06:00 +0900</pubDate>
        <guid>https://myuon.github.io/posts/2017csadv-day1/</guid>
        <description>これは一人Computer Scienceアドベントカレンダー 1日目の記事です。
概要的なもの 「一人アドベントカレンダーって面白そうだな、やってみたい」みたいなノリで登録したんですが、 25日毎日記事を同じテーマで投稿し続けるのどう考えてもめっちゃ大変なのでやはりここは自分が一番得意な分野で行くしかないかなとなりCS関係ということになりました。
上のQiitaのページでも書いてますが、キーワードとして&#34;ラムダ計算・定理証明・Haskell・ML・圏論 とかなんかそのへん&#34;を挙げていますので そのへんのお話になります。今のところは無難に定理証明を中心にテーマをいくつか選んでおいたので多分そのへんの話です。
スケジュール 最終的にはQiitaのカレンダー見ればわかることなんでいいんですが一応今後どういう感じで進めていくのかのスケジュール的なものをまとめておきます。
Isabelle編 Isabelle/HOL入門(3-4日くらい) 最初にIsabelle(ここではHOL系しか扱わない)に入門します。って言ってもチュートリアルの解説をするだけです。 ある程度知ってる人が読む意味はないんですが、Isabelle全く知らん人向けに日本語で読める資料ってあんまりなさそうなので、チュートリアルを適当にやるだけでも実は意味があるんでは的な発想でとりあえずこれをやることにしました。
真面目に入門したくて英語にそこまで抵抗ない人は公式のprog-prove.pdf読みに行く方が早いです。
Isabelleでの定理証明・基礎編(3-4日くらい) ここでは実際にIsabelle/HOLを使った証明を紹介・解説していきます。今の所IMPの意味論ちょろっとやるみたいな感じです。 Isabelleの解説がメインなので内容は薄いですがIsabelleってこうやって使うんだよ〜証明ってこうやって書くんだよ〜って雰囲気が伝わればいいかなと思っています。 (そういうのが伝わる日本語資料もあんまりない気がしたので)
Isabelleでの定理証明・実践編(2-3日+2日？くらい) せっかくなので個人的にこの前お世話になったりしたNominal Isabelle使ってtyped lambda calculusの簡単な証明とかやってみようかなという内容です。 あとかつてIsabelleで圏論(Yoneda lemma示すくらいまで)もやったことあるのでその解説もやってもいいかもしれないということで2日分くらいは余裕を持たせてあります。
この辺は後で変更あるかも知れないのでそのへんはあしからず。
Haskell編 ライブラリ紹介(1日1ライブラリ, 日数未定) Haskellで最近使ったり使ってなかったりするライブラリの紹介とか解説とかをします。 ここ以外のコンテンツで25日分埋まらなかった場合に備えて空けてある枠なので日数は未定です。 Haskell編の最初にまとめてやるかも不明ですが一応ってことで。
定理証明支援系を作ろう・理論編(2-3日くらい) ここからがメインコンテンツで、Haskellを使ってproof assistantを作ります。 (最初に断っておくとproverは作りません。あくまでcheckerとそのassistする部分がメインです。)
多分色々前提になる知識を解説したり、proof assistantを作るには何が必要かとかの説明がいると思うのでそのへんを初めに少し解説します。
定理証明支援系を作ろう・実践編(5-7日くらい) proof assistantを実際に作っていきます。
最初はステップアップで徐々に拡張して行く感じで作ろうと思っていたんですが、特に参考にできるものもなく始めてだったので自分で手を動かして作ってみた所そうそう前に進めるはずもなく backwardな変更が出過ぎてステップアップするのつらすぎたので普通に現在のproof assistantのコードの解説になります。
checkerのコア機能の解説→assist機能関係の解説→プラグイン・拡張部分の解説 の順になります。
定理証明支援系を作ろう・拡張編(1日) 上で作ったものは当然ですがまともに証明を書こうとすると色々足りないので、今後ちゃんとしたassistantにするにはどういう感じの拡張が欲しいかな〜とかそういう話を、 「開発が間に合わなかったものは全部読者への演習問題にしたらええねん」的な思想により丸投げされるコーナーです。
まとめ 最終日は多分まとめと振り返りに使います。
これでだいたい25日分になるはず。
意気込み的な 開催にあたり内容よりも25日にわたってずっとブログを書き続けるのがつらそう という感情しかないんですが まぁせっかくなので楽しんでいこうと思います。
あと無理はよくないのでしんどくなったら細切れにしていこうというのも気をつけていきたい。
というわけで、読んでくれる人は25日の間どうぞお付き合いください。よろしくお願いします。</description>
      </item>
    
      <item>
        <title>HakyllからHugoに移行した</title>
        <link>https://myuon.github.io/posts/migrate-to-hugo/</link>
        <pubDate>Fri, 10 Nov 2017 02:37:31 +0900</pubDate>
        <guid>https://myuon.github.io/posts/migrate-to-hugo/</guid>
        <description>移行理由 前はHakyll+pandocでorg-modeで書く→htmlに変換してgithub pagesで公開という手順を踏んでいたのだけれど、pandocのorg-mode対応が中途半端すぎて、対応していない記法があったりcode block(こういうの)の中で特殊な記号を使うと上手くパース出来なかったりして色々厳しくなってきていたというのが理由。 困ってたところにhugoというのを教えてもらったのでそれに移行することにした。
手順諸々 導入 hugoをsnapdから入れて使う。テストサイトを作って挙動を確認してから必要なものをsourceブランチに持ってきて導入はおしまい。 各記事はfront matterを少し書きなおすだけ。ありがたいことにorg-modeでかく場合は大体似たような文法なのでちょこっと書き換えるだけで動く。
hugo serve --watch --buildDrafts でドラフトも見れるようにできるので、ドラフト確認してOKならhugoからpublishするというのが正しいフローっぽい。
テーマ Hakyllの時からテーマは自作していたのでテンプレートのカスタマイズとcssを持ってくるみたいな作業が必要になったのでやった。 hugo new theme [テーマ名] で必要なファイル群が themes にできるのであとは Templates にテンプレートの公式ドキュメントがあるのでそれとかhugoの実際のテンプレートを見てカスタマイズをした。
まぁ変に汎用性とか気にしなければ簡単、だと思う。
コードのsyntax highlight config.tomlに
pygmentscodefences = true pygmentsstyle = &amp;#34;manni&amp;#34; と書いた。 pygmentscodefencesはmarkdownで ```lang みたいに書けるようにするやつだけど、org-modeのcode blockもありがたいことに対応してくれてたのでそのまま色がついた。
カラースキームはPygmentsの公式サイトから色々試してしっくり来るやつを探すと良さそう。
syntax highlight関係のデザイン pandocではsyntax highlight用にcssを用意して色を指定していたんだけどそれが不要になった。 それと、pygmentsstyleで色をつけるとpreの背景の色を強制的に指定されてしまうので今までは色をつけてたんだけどそれを外した(文章中のcodeはそのままにしてる)。
TOC 困ったことにorg-modeだとtocが表示されないバグがあるらしく1、調べたらテンプレートだけでTOCを作る方法があったのでそれをパクった。 リストを作ってCSSでheadingに応じて右にずらしているだけだけど。
semantic-uiの読み込み このブログではsemantic-uiをcssフレームワークとして使っていて、できればそれらのファイルを自分のリポジトリに含めてcommitするのは避けたかったのでsubmoduleで頑張った。 と言っても git submodule add URL directory とかして管理するだけだけど。 公開するときとローカルビルドするときのどちらも必要になるのでどちらもsubmoduleに追加する必要がある。 それと、URLはgit@...じゃなくてhttps:... じゃないとだめらしい。(一度怒られた)
hard line breaks これはやり方がわからない。 orgで書いた時に、パラグラフ中の改行はHTMLで強制改行に(&amp;lt;br&amp;gt; に)してほしい。 #+OPTIONS: \n:t 相当のやつ。markdownは対応しているみたいだけど…。</description>
      </item>
    
      <item>
        <title>n番煎じのrecursion-scheme</title>
        <link>https://myuon.github.io/posts/recursion-scheme/</link>
        <pubDate>Fri, 27 Oct 2017 00:59:31 +0900</pubDate>
        <guid>https://myuon.github.io/posts/recursion-scheme/</guid>
        <description>前提になりそうなことをちょこっとPreliminariesに書いた.
Recursion schemes 以下, C は適当な条件を満たすfunctor F: C -&amp;gt; C がFixをもち, さらにそれがCofixにもなっていることを仮定する1. 以下ではこの適当な条件を満たすfunctorしか考えないものとする.
catamorphism F-algebra p: FA -&amp;gt; A に対し, D のinitialityにより得られる射 cata(p): D -&amp;gt; A を catamorphism とよぶ. これは in; cata(p) = fmap F cata(p); p: FD -&amp;gt; A を満たす.
anamorphism catamorphismの双対. F-coalgebra q: A -&amp;gt; FA に対し, D のterminalityにより得られる射 ana(q): A -&amp;gt; D を anamorphism とよぶ. これは q; fmap F ana(q)  ana(q); out= を満たす.
hylomorphism F-algebra p: FB -&amp;gt; B と F-coalgebra q: A -&amp;gt; FA に対し, hylo(p,q) = ana(q); cata(p) : A -&amp;gt; B を hylomorphism とよぶ.</description>
      </item>
    
      <item>
        <title>Overlapping Instancesと戦う</title>
        <link>https://myuon.github.io/posts/overlapping-instances/</link>
        <pubDate>Mon, 21 Aug 2017 00:31:03 +0900</pubDate>
        <guid>https://myuon.github.io/posts/overlapping-instances/</guid>
        <description>Overlapping Instances Haskellで少し凝ったinstanceをいくつか書いたりしているとoverlapping instancesに悩まされることはよくある。 この辺のまとまった解説があると便利なのではと思ったので書く。
ユーザーガイドにて 実際、overlapping instancesが何故起こるのかについてはGHCユーザーガイドにそれなりに詳しく書いてあるのでそこを読めば良いと思う。
GHCユーザーガイド - Overlapping instances
勝手に抄訳すると次のような感じ
9.8.3.6 Overlapping instances   一般に、Instance resolutionで述べたように、 GHCは、型クラス制約を解決するために使用されるinstance宣言が曖昧ではないことを要求する。 GHCは、 最も具体的な形が存在する時に限って 複数のinstanceにマッチすることを許すという方法で、instanceの解決を緩める方法も提供している。さらに、これはもっと緩くすることもできて、最も具体的な形があるかどうかにかかわらず、複数のinstanceにマッチすることを許すこともできる。この節で詳しく述べる。  instanceの選択をコントロールするには、それぞれのinstanceについてオーバーラップしたときの挙動を指定することができる。 instance キーワードの直後に次のいずれかのプラグマを書けば良い: {-# OVERLAPPING #-}, {-# OVERLAPPABLE #-}, {-# OVERLAPS #-} または {-# INCOHERENT #-}  INCOHERENT はinstanceが自由にoverlapしたりされたりすることを許すが、使わないほうがいいプラグマなので出来る限り避けたほうがいい。 また、後にもあるように OVERLAPS は OVERLAPPING と OVERLAPPABLE のいずれにもなるので OVERLAPS で事足りる場合も多いと思う。
また、いちいちプラグマを書かなくてもいいように、デフォルトの挙動を指定するための拡張 -XIncoherentInstances と -XOverlappingInstances も あるけれど使用は出来る限り避けよう。
  さて、あるクライアントモジュールで (C ty1 .. tyn) なる制約の対象になるようなinstanceを探しているとしよう。この検索は次のようにして行われる:  - 対象となる制約に マッチする instance I を全て見つける。つまり、対象となる制約 (C ty1 .</description>
      </item>
    
      <item>
        <title>HakyllでBlogを作る</title>
        <link>https://myuon.github.io/posts/hakyll-blog/</link>
        <pubDate>Wed, 16 Aug 2017 22:39:48 +0900</pubDate>
        <guid>https://myuon.github.io/posts/hakyll-blog/</guid>
        <description>Hakyllでこのブログを作ったのでそのあれこれを
概要 やりたいことは以下
 orgで文章をかく(大事) orgから良い感じのHTMLを生成し github pagesで公開  Hakyllのsetup 次を参考にした
 Hakyll Tutorials Hakyll, stack, Travis CI, Github でブログを管理する GitHub Pages はじめました hakyll package  stack でパッケージを入れて、 hakyll-init → stack build → stack exec site watch で動かすところまでは簡単にいけた 2番目のリンクにあるように、 _site をsubmoduleに登録しておいて、これをmasterブランチにpushして公開するようにしておく
文書の変換・Hakyllの設定 プロジェクトの構造は次のようになっている
- root - _site できたHTMLファイルが置かれる - _cache - css できたCSSファイルが置かれる(圧縮済) - images 画像ファイルが(ry - posts ここにorg or markdownで書いた記事を入れる - site.hs Hakyllの設定ファイル orgの変換 Hakyllは内部で文書変換にpandocを使っていて、pandocはorgに対応しているらしいので何も設定しなくても変換はできる (デフォルトの状態では posts 以下の文書ファイルが変換される)
ただし、次の2つをやりたかったのであれこれ設定をかいた</description>
      </item>
    
  </channel>
</rss>
